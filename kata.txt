
Finding median via two heaps
  - maintain min and max heaps 
  - when a new element arrives, check if it's smaller than smallest of max then it goes to min heap 
  - rebalance both heaps 


Dijkstra alg - naive impl - O(N*M) but with heap (M Log N)

Greedy algorithm 
  Dijkstra shortest path 
  iteratively makes myopic decision, hope everything works out at the end 
  divide and conquer problem -- solve sub problem (e.g. merge sort)


Scheduling problem 
  weight - priority of job
  length - how long job will take to run 
  completion time of job = wall time (includes waiting time before job is actually run)
  objective func - minimize sum of completion time x weight = minimze weighted average completion time 




 Given an array with all final grades for a course and the minimum grade that a student needs to have in order to pass the course

Your task is to

    write a function that counts the number of students that passed and prints this number to standard output (stdout)

Note that your function will receive the following arguments:

    grades
        which is the list of grades, represented as integer numbers
    min_grade
        which is the minimum grade that a student can get, so that he passes the course

Data constraints

    the length of the array given as input will not exceed 1000 elements

Example
Input   Output

grades: 1, 2, 8, 4, 5, 8, 3
min_grade: 5
    
3

class MyClass {
    public static void count_successful_students(Integer[] grades, Integer min_grade) {
        int matched = 0;
        for (Integer grade : grades) {
            if (grade >= min_grade) {
                matched++;
            }
        }
        System.out.println(matched);
    }
}


 An easy way to understand how well the students performed at this years course is to compute the average of their final grades. If it is higher that the average for last year, that means the course was easier than last year.

Given an array with all final grades for a course

Your task is to

    write a function that computes the average of all the grades in the array and prints this number to standard output (stdout)
    the result must be rounded downwards to the nearest integer (e.g. both 7.1 and 7.9 are rounded to 7)

Note that your function will receive the following arguments:

    grades
        which is the list of grades, represented as integer numbers

Data constraints

    the length of the array given as input will not exceed 1000 elements


class MyClass {
    public static void compute_average_grade(Integer[] grades) {
        int sum = 0;
        for (Integer grade : grades) {
            sum += grade;
        }
        System.out.println(sum/grades.length);
    }
}



 Students are graded for their activity in each lab session.

It is expected that a students performance improves in time, which means that he should always receive a grade equal to or higher than the grade he received in the previous lab.

Given an array with the lab grades of a student

Your task is to

    write a function that checks whether the grades received by each student are in ascending order
    your function must print to standard output (stdout):
        1 if the grades are in ascending order (e.g. 1, 3, 3, 7)
        0 if the grades are not in ascending order (e.g. 1, 3, 7, 3)

Note that your function will receive the following arguments:

    grades
        which is an array containing the grades of the student

Data constraints

    the length of the array given as input will not exceed 1000 elements


class MyClass {
    public static void is_sorted(Integer[] grades) {
        for (int i=1; i<grades.length; i++) {
            if (grades[i-1] > grades[i]) {
                System.out.println(0);
                return;
            }
        }        
        System.out.println(1);
    }
}


 A student's performance in lab activities should always improve, but that is not always the case.

Since progress is one of the most important metrics for a student, lets write a program that computes the longest period of increasing performance for any given student.

For example, if his grades for all lab activities in a course are: 9, 7, 8, 2, 5, 6, 8, 7 then the longest period would be 4 consecutive labs (2, 5, 6, 8).

Given an array with the lab grades of a student

Your task is to

    write a function that computes and prints to standard output (stdout) the longest period of increasing performance for the student that has these grades

Note that your function will receive the following arguments:

    grades
        which is an array containing the grades of the student

Data constraints

    the length of the array given as input will not exceed 1000 elements


class MyClass {
    public static void longest_improvement(Integer[] grades) {
        int matched = 1;
        int max = -1;
        for (int i=1; i<grades.length; i++) {
            if (grades[i-1] <= grades[i]) {
                matched++;
                max = Math.max(matched, max);
            } else {
                matched = 1;
            }
        }
        System.out.println(max);
    }
}


 After an exam all the students are graded and sorted by their grades.

In some cases, students talk to the professor and conclude that one of the tougher problem statements in the exam was unclear and the teacher decides to remove its contribution towards the final grade.

Since its just one of many challenges, the sorted list of students wont change much - only a few students might change their order.

How do we implement an efficient algorithm that sorts a list of numbers that are almost sorted? Bubble sort is the perfect one for this specific case:

    bubblesort(A):
    repeat
        changed = false
        for i = 1 to length(A) - 1
            if A[i - 1] > A[i]
                swap A[i - 1], A[i]
                changed = true
    until not changed
  

Given an array of integer numbers

Your task is to

    implement the bubblesort algorithm to sort the array in ascending order and print the sorted elements to standard output (stdout), one per line

Note that your function will receive the following arguments:

    numbers
        which is the array of integer numbers that needs to be sorted

Data constraints

    the length of the array given as input will not exceed 1000 elements


import java.util.*;
class MyClass {
    public static void sort_students(Integer[] numbers) {
        Arrays.sort(numbers);
        for (Integer n : numbers) {
            System.out.println(n);
        }
        
    }
}



 A teacher wants to compare the performance of two students. To understand them better, hes looking at all the other courses they took, but its hard to spot the common courses just from a glance.

Given two arrays that contain the course IDs of two different students

Your task is to

    write a function that prints to standard output (stdout) all the course IDs that are contained in both arrays, sorted in ascending order, one per line

Note that your function will receive the following arguments:

    courses1
        which is the list of course IDs for the first student
    courses2
        which is the list of course ids for the second student

Data constraints

    the length of the array given as input will not exceed 1000 elements



import java.util.*;
class MyClass {
    private static boolean exists(Integer[] arr, int n) {
        for (Integer i : arr) {
            if (i.equals(n)) {
                return true;
            }
        }
        return false;
    }
    public static void get_common_courses(Integer[] courses1, Integer[] courses2) {
        List<Integer> list = new ArrayList<Integer>();
        for (int i=0; i<courses1.length; i++) {
            if (exists(courses2, courses1[i])) {
                list.add(courses1[i]);
            }
        }
        
        Collections.sort(list);
        for (Integer n : list) {
            System.out.println(n);
        }
    }
}

 common operation with text editors is selecting a block of text for further manipulation. Lets see how an editor extracts the characters between two given positions in a string.

Given a string S and two integer numbers p1, p2

Your task is to

    write a function that extracts all the characters between positions p1 and p2 in the given string and prints these characters to standard output (stdout)

Note that your function will receive the following arguments:

    s
        which is the string from which you must extract the specified characters
    p1
        which is the position of the left-most character that you must extract
    p2
        which is the position of the right-most character that you must extract

Data constraints

    the string will contain at most 1000 characters

class MyClass {
    public static void select_substring(String s, Integer p1, Integer p2) {
        StringBuilder sb = new StringBuilder();
        for (int i=p1-1; i<p2 && i<s.length(); i++) {
            sb.append(s.charAt(i));
        }
        System.out.println(sb);
    }
}



 Another common operation is deleting characters starting from the position of our cursor in the editor.

Given a string S, a position in this string P and a number N

Your task is to

    write a function that deletes N characters from the string S, starting from position P
    your function must print the newly formed string to standard output (stdout)

Note that your function will receive the following arguments:

    s
        which is the string from which we must delete the specified characters
    p
        which is the position in the string from which we must start deleting characters
    n
        which is the number of characters that must be deleted

Data constraints

    the string will contain at most 1000 characters

class MyClass {
    public static void remove_substring(String s, Integer p, Integer n) {
        StringBuilder sb = new StringBuilder();
        for (int i=0; i<s.length() && i< p-1; i++) {
            sb.append(s.charAt(i));
        }
        for (int i=p+n-1; i<s.length(); i++) {
            sb.append(s.charAt(i));
        }
        System.out.println(sb);        
    }
}




 When writing text we frequently use the copy and paste commands. Lets see how an editor implements the paste command.

Given two strings S1 and S2 and an integer number P

Your task is to

    write a function that inserts S2 into S1 starting with the position P in S1 and then prints the newly formed string S1 to standard output (stdout)

Note that your function will receive the following arguments:

    s1
        which is the string in which we must make the insertion
    s2
        which is the string that needs to be inserted
    p
        which is the position in s1 where s2 must be inserted

Data constraints

    the strings will contain at most 1000 characters



class MyClass {
    public static void copy_string(String s1, String s2, Integer p) {
        StringBuilder sb = new StringBuilder();
        for (int i=0; i<s1.length() && i< p; i++) {
            sb.append(s1.charAt(i));
        }
        sb.append(s2);
        for (int i=p; i<s1.length(); i++) {
            sb.append(s1.charAt(i));
        }
        System.out.println(sb);        
    }
}

 When writing an essay it is useful to know the total number of words that we have typed.

Let's define a word as any number of characters separated by spaces and commas. For example the string " one, ,two three,4," contains 4 words.

Given a string S

Your task is to

    write a function that counts the number of words in the given string and prints this number to standard output (stdout)

Note that your function will receive the following arguments:

    s
        which is the string for which you must count the number of words

Data constraints

    the string will contain at most 1000 characters



import java.util.*;
class MyClass {
    public static void count_words(String s) {
        StringTokenizer st = new StringTokenizer(s, " ,");
        int count = 0;
        while (st.hasMoreTokens()) {
            String next = st.nextToken();
            if (next.trim().length() > 0) {
                count++;
            }
        }
        System.out.println(count);
    }
}



 Some advanced code editors allow programmers to sort the words from a selected block of text. This is useful when we are polishing our code to make sure everything is readable and consistent.

Lets define a word as any number of characters separated by spaces and commas. For example the string " one, ,two three,4," contains 4 words.

Given a string S

Your task is to

    write a function that sorts all the words in the string alphabetically and prints them to standard output (stdout) in sorted order, one on each line

Note that your function will receive the following arguments:

    s
        which is the string from which you must extract and sort the words

Data constraints

    the string will contain at most 1000 characters

Example


import java.util.*;
class MyClass {
    public static void sort_words(String s) {
        StringTokenizer st = new StringTokenizer(s, " ,");
        List<String> words = new ArrayList<String>();
        while (st.hasMoreTokens()) {
            String next = st.nextToken().trim();
            if (next.length() > 0) {
                words.add(next);
            }
        }
        Collections.sort(words);
        for (String word : words) {
            System.out.println(word);
        }
    }
}



Given an integer number N

Your task is to

    write a function that prints to the standard output (stdout) the numbers from 1 to N (one per line) with the following restrictions
        for multiples of three print Fizz instead of the number
        for the multiples of five print Buzz instead of the number
        for numbers which are multiples of both three and five print FizzBuzz

Note that your function will receive the following arguments:

    n
        which is the integer number described above

Data constraints

    the maximum value of N will not exceed 1000

Efficiency constraints

    your function is expected to print the result in less than 2 seconds



class MyClass {
    public static void fizzbuzz(Integer n) {
        for (int i=1; i<=n; i++) {
            if (i % 3 == 0 && i % 5 == 0) {
                System.out.println("FizzBuzz");
            } else if (i % 3 == 0) {
                System.out.println("Fizz");
            } else if (i % 5 == 0) {
                System.out.println("Buzz");
            } else {
                System.out.println(i);
            }
        }
        
    }
}



As soon as a user inputs a query, the search engine must tokenize it - that means break it down into understandable tokens. A token is defined as a sequence of characters separated by white spaces and/or punctuation.

Given a string representing a user query and a set of punctuation characters

Your task is to

    write a function that prints to the standard output (stdout) all the tokens in the user query (one per line)

Note that your function will receive the following arguments:

    query
        which is a string giving the user query
    punctuation
        which is a string giving the punctuation characters that separate tokens

Data constraints

    the size of the query string will not exceed 1000 characters
    the size of the punctuation string will not exceed 10 characters

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example



import java.util.*;
class MyClass {
    public static void tokenize_query(String query, String punctuation) {
        StringTokenizer st = new StringTokenizer(query, punctuation + " ");
        List<String> words = new ArrayList<String>();
        while (st.hasMoreTokens()) {
            String next = st.nextToken().trim();
            if (next.length() > 0) {
                words.add(next);
            }
        }
        for (String word : words) {
            System.out.println(word);
        }        
    }
}



Stop words are tokens which are filtered out from queries because they add little value in finding relevant web pages.

Given a list of tokens that were obtained after the search engine tokenized the user query using your code from the previous task and a list of stopwords

Your task is to

    write a function that prints to the standard output (stdout) all the tokens in the user query that are not stop words (one per line)

Note that your function will receive the following arguments:

    query
        which is an array of strings giving the tokens in the user query
    stopwords
        which is an array of strings giving the stop words

Data constraints

    the length of the query array will not exceed 1000
    the length of the stopwords array will not exceed 1000
    all string comparisons are case-sensitive (i.e: Cool != cool)

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds



import java.util.*;
class MyClass {
    public static void remove_stopwords(String[] query, String[] stopwords) {
        List<String> result = new ArrayList<String>();    
        for (int i=0; i<query.length; i++) {
            boolean matched = false;
            for (int j=0; j<stopwords.length; j++) {
                if (query[i].equals(stopwords[j])) {
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                result.add(query[i]);
            }
        }
        for (String word : result) {
            System.out.println(word);
        }
    }
}


Stemming removes word suffixes to reduce inflected (or sometimes derived) words to their base or root form.

E.g. friendly is an inflection of friend. By stemming (in this case stemming means removing the suffix ly), friendly is reduced to friend.

Given a list of tokens and a list of suffixes

Your task is to

    write a function that prints to the standard output (stdout) all the tokens having their suffix removed if found in the list of suffixes (please print one token per line)
    for each token if there is more than one suffix that can be removed please choose the one that is the longest

Note that your function will receive the following arguments:

    tokens
        which is an array of strings giving the tokens described above
    suffixes
        which is an array of strings giving the suffixes described above

Data constraints

    the length of the tokens array will not exceed 1000
    the length of the suffixes array will not exceed 100
    all string comparisons are case-sensitive (i.e: Cool != cool)

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example



import java.util.*;
class MyClass {
    private static final Comparator<String> CMP = new Comparator<String>(){
        @Override
        public int compare(String o1, String o2) {  
            if (o1.length() > o2.length()) {
                return 1;
            } else if (o1.length() < o2.length()) {
                return -1;
            }
            return o1.compareTo(o2);
        }
    };
    public static void token_stemming(String[] tokens, String[] suffixes) {
        List<String> result = new ArrayList<String>();
        Arrays.sort(suffixes, CMP);
        for (int i=0; i<tokens.length; i++) {
            String word = tokens[i];
            for (int j=suffixes.length-1; j>=0; j--) {
                if (tokens[i].endsWith(suffixes[j])) {
                    word = word.substring(0, word.length()-suffixes[j].length());
                    break;
                }
            }
            result.add(word);
        }
        for (String word : result) {
            System.out.println(word);
        }        
    }
}



It's time to retrieve the web pages that match a user query.

Given a query as a list of tokens and a list of strings representing the content of each web page

Your task is to

    write a function that prints to the standard output (stdout) the number of web pages that contain all the given tokens in the same order.

Note that your function will receive the following arguments:

    query
        which is an array of strings giving the tokens in the user query
    pages
        which is an array of strings giving the content of each web page

Data constraints

    the length of the query array will not exceed 10
    the length of the pages array will not exceed 1000
    the length of any web page content will not exceed 1000
    all string comparisons are case-sensitive (i.e: Cool != cool)

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example


class MyClass {
    public static void search_query(String[] query, String[] pages) {
        int count = 0;
        for (int i=0; i<pages.length; i++) {
            int matched = 0;
            int index = 0;
            for (int j=0; j<query.length; j++) {
                int mndx = pages[i].indexOf(query[j], index);
                if (mndx != -1) {
                    index = mndx + query[j].length();
                    matched++;
                }
            }
            if (matched == query.length) {
                count++;
            }
        }
        System.out.println(count);
        
    }
}



Challenge: Context extraction

Considering the name of a book and the tweet mentioning it we define the context of the book as a sequence of tokens immediately preceding and immediately following the book name in the tweet.

    A token is defined as a sequence of characters that occur between white spaces.
    The size of the context is W tokens on each side (preceding and following the book name)

For example, having the book title "Beautiful Code", W=2 and the following tweet

"I read Beautiful Code and it was simply amazing"

the context is "I read -TITLE- and it"

Given a list of book titles, a list of tweets and W

Your task is to

    write a function that prints to the standard output (stdout) for each book all the contexts that can be extracted from the list of tweets (one per line in the same order with the tweets that generated those contexts)
    each context must be printed as a string formed by concatenating the tokens preceding the book title, the keyword "-TITLE-" (one white space on both sides) and the tokens following the book title
    please take into consideration the following constraints:
        A book title matches a tweet if all its tokens match a sequence of consecutive tokens in the tweet (e.g. "Beautiful Code" does not match "Beautiful A Code")
        If the number of available tokens preceding or following a book title is lower than W extract only those available.
        If a context is empty on both the left and the right side it must be ignored, otherwise it is considered valid

Note that your function will receive the following arguments:

    books
        which is an array of strings representing the book titles
    tweets
        which is an array of strings representing the tweets
    w
        which is an integer number as described above

Data constraints

    the length of the books array will not exceed 50
    the length of the tweets array will not exceed 10000

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example


class MyClass {
    public static void extract_contexts(String[] books, String[] tweets, Integer w) {
        for (int j=0; j<books.length; j++) {
            for (int i=0; i<tweets.length; i++) {
                int ndx = 0;
                StringBuilder sb = new StringBuilder();

                while ((ndx=tweets[i].indexOf(books[j], ndx)) != -1) {
                    String[] prefix = tweets[i].substring(0, ndx).split(" ");
                    for (int k=prefix.length-1, l=0; k >= 0 && l<w; k--, l++) {
                        String word = prefix[k].trim();
                        if (word.length() == 0) {
                            l--;
                            continue;
                        }
                        if (sb.length() > 0) {
                            sb.insert(0, " ");
                        }
                        
                        sb.insert(0, word);
                    }
                    sb.append(" -TITLE- ");
                    ndx += books[j].length();
                    String[] suffix = tweets[i].substring(ndx).split(" ");

                    for (int k=0, l=0; k < suffix.length && l<w; k++, l++) {
                        String word = suffix[k].trim();
                        if (word.length() == 0) {
                            l--;
                            continue;
                        }
                        sb.append(word);
                        if (k<suffix.length-1 && l<w-1) {
                            sb.append(" ");
                        }
                    }
                }
                final String result = sb.toString().trim();
                if (result.length() > 0) {
                    System.out.println(result);
                }
            }
        }
        
    }
}


Challenge: Trigger words

Lets consider a context that was extracted during the previous challenge:

Did you read -TITLE- on Kindle yesterday?

In this example, "read" and "Kindle" are trigger words. These types of words signal that theres a high likelihood of finding a book title in their vicinity.

A trigger word is a token that has two properties:

    it is frequent in the list of extracted contexts
    it is specific to the field of books

In order to identify trigger words we are going to assign a weight to each token. Lets call this weight: IDF ("inverse document frequency").

IDF(token) = log(N / num_contexts(token))

    N represents the total number of contexts we are working with
    num_contexts(token) represents the number of contexts that contain the given token
    log() represents the natural logarithm (base E) of a number.

Given a list of contexts and an integer number M

Your task is to

    write a function that prints to the standard output (stdout) the first M tokens having the highest IDF value (one per line)
    if there are more tokens having the same IDF value they must be sorted in lexicographical order

Note that your function will receive the following arguments:

    contexts
        which is an array of strings giving a list of contexts
        each context is a string of tokens containing the keyword "-TITLE-" (separated by spaces) which delimits the left side of the context and the right side of it
    m
        which is an integer number giving the number mentioned above

Data constraints

    the length of the contexts array will not exceed 1000
    the length of a context string will not exceed 1000 characters

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

contexts: "to read -TITLE- while in", "to buy -TITLE- while in school", "buy -TITLE-"

m: 2
    

read
school

Explanation

    In this example we are working with 3 contexts, so N = 3
    IDF("read") = log(3/1) = 1.09
    IDF("buy") = log(3/2) = 0.40



import java.util.*;
class MyClass {
    static int N;
    static class Info implements Comparable<Info> {        
        String token;
        int num_context;
        public Info(String token) {
            this.token = token;
            num_context = 1;
        }
        double idf() {
            return Math.log(N / num_context);            
        }
        @Override
        public int compareTo(Info other) {
            if (other.idf() < idf()) {
                return -1;
            } else if (other.idf() > idf()) {
                return +1;
            } else {
                return token.compareTo(other.token);
            }
        }
        @Override public String toString() {
            return token + ", N " + N + ", num " + num_context + ", idf " + idf() + "\n";
        }
    }
    public static void extract_trigger_words(String[] contexts, Integer m) {
        N = contexts.length;
        Map<String, Info> idfMap = new TreeMap<String, Info>();
        for (String c : contexts) {
            String[] arr = c.split(" ");
            Arrays.sort(arr);
            for (int i=0; i<arr.length; i++) {
                if (!arr[i].equals("-TITLE-")) {
                    Info info = idfMap.get(arr[i]);
                    if (info == null) {
                        idfMap.put(arr[i], new Info(arr[i]));
                    } else {
                        if (i > 1 && arr[i-1].equals(arr[i])) {
                            //skip
                        } else {
                            info.num_context++;
                        }
                    }
                }
            }
        }
        List<Info> idfList = new ArrayList<Info>(idfMap.values());
        Collections.sort(idfList);
        for (int i=0; i<m && i<idfList.size(); i++) {
            System.out.println(idfList.get(i).token);
        }
    }
}

Context pruning

Youve obtained the set of trigger words, congrats!

Its time to remove the tokens that are not useful in predicting a book title in their vicinity from each context. This operation is called pruning.

Pruning each context is done in the following fashion:

    select the token which is a trigger word and has the highest IDF (inverse document frequency)
    if none of the tokens is a trigger word then ignore the context
    if the token is on the left side of the context
        we keep the token and all tokens on its right
        for the right side of the context we keep only the first token (if exists)
    if the token is on the right side of the context
        we keep the token and all tokens on its left
        for the left side of the context we keep only the last token (if exists)

Considering the list of trigger words [Kindle, read] sorted in ascending order by their IDF, pruning the context: Did you read -TITLE- on Kindle yesterday? will produce the following result:

    read -TITLE- on

Given a list of contexts and a list of trigger words sorted in ascending order by IDF

Your task is to

    write a function that prunes the contexts and prints the results to the standard output (stdout)

Note that your function will receive the following arguments:

    contexts
        which is an array of strings giving a list of contexts
        each context is a string of tokens containing the keyword "-TITLE-" (separated by spaces) which delimits the left side of the context and the right side of it
    triggers
        which is an array of strings representing trigger words sorted in ascending order by IDF

Data constraints

    the length of the contexts array will not exceed 1000
    the length of a context string will not exceed 1000 characters
    the length of the triggers array will not exceed 1000
    the length of a trigger word will not exceed 100 characters

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

contexts: "to read -TITLE- while in", "to buy -TITLE- while in school", "buy -TITLE-"

triggers: "read", "school"
    

read -TITLE- while
buy -TITLE- while in school




import java.util.*;
class MyClass {
    
    private static void append(List<String> contextTokens, String matchingTrigger, String leftOfTitle,String rightOfTitle, StringBuilder sb) {
        boolean printedTitle = false;
        for (int i=0; i<contextTokens.size(); i++) {
            if (contextTokens.get(i).equals(matchingTrigger)) {
                continue;
            }
            if (sb.length() > 0) {
                sb.append(" ");
            }
            if (!printedTitle && rightOfTitle != null && contextTokens.get(i).equals(rightOfTitle)) {
                sb.append("-TITLE- ");
                printedTitle = true;
            }
            sb.append(contextTokens.get(i));
            if (!printedTitle && leftOfTitle != null && contextTokens.get(i).equals(leftOfTitle)) {
                sb.append(" -TITLE-");
                printedTitle = true;
            }
        }
        if (!printedTitle) {
            sb.append(" -TITLE-");
        }
    }
    private static boolean idfHigher(String matchingTrigger, String token, String[] triggers) {
        int matchingIdfIndex = -1;
        int tokenIdfIndex = -1;
        for (int i=0; i<triggers.length; i++) {
            if (triggers[i].equals(matchingTrigger)) {
                matchingIdfIndex = i;
            }
            if (triggers[i].equals(token)) {
                tokenIdfIndex = i;
            }
        }
        if (matchingIdfIndex == -1 || tokenIdfIndex == -1) {
            return false;
        }
        return matchingIdfIndex < tokenIdfIndex; // triggers are in asc IDF
    }
    public static void context_pruning(String[] contexts, String[] triggers) {
        for (String context : contexts) {
            String matchingTrigger = null;
            boolean matchedTokenOnLeftSide = true;
            String leftOfTitle = null;
            String rightOfTitle = null;
            List<String> contextTokens = new ArrayList<String>();
            List<String> tokensSinceMatchingToken = new ArrayList<String>();
            boolean foundTitle = false;
            for (String token : context.split(" ")) {
                if (token.equals("-TITLE-")) {
                    foundTitle = true;
                    if (matchingTrigger == null) {
                        contextTokens.clear();
                    }
                    continue;
                }
                //
                if (!foundTitle) {
                    leftOfTitle = token;
                } else if (rightOfTitle == null) {
                    rightOfTitle = token;
                }
                //
                for (String trigger : triggers) {
                    if (token.equals(trigger) && (matchingTrigger == null || idfHigher(matchingTrigger, token, triggers))) {
                        matchingTrigger = token;
                        if (foundTitle) {
                            matchedTokenOnLeftSide = false;
                        } else {
                            contextTokens.clear();
                            matchedTokenOnLeftSide = true;
                        }
                        for (String t : tokensSinceMatchingToken) {
                            if (contextTokens.indexOf(t) == -1) {
                                contextTokens.add(t);
                            }
                        }
                        tokensSinceMatchingToken.clear();
                    } else if ((matchingTrigger == null || !foundTitle) && !token.equals(matchingTrigger)) {
                        if (contextTokens.indexOf(token) == -1) {
                            contextTokens.add(token);
                        }
                    } else if (matchingTrigger != null && !token.equals(matchingTrigger) && tokensSinceMatchingToken.indexOf(token) == -1) {
                        tokensSinceMatchingToken.add(token);
                    }
                }
            }
            if (matchingTrigger == null) {
                // ignore 
                continue;
            }
            StringBuilder sb = new StringBuilder();
            if (matchedTokenOnLeftSide) {
                sb.append(matchingTrigger);
                append(contextTokens, matchingTrigger, leftOfTitle, rightOfTitle, sb);

                if (rightOfTitle != null && contextTokens.indexOf(rightOfTitle) == -1) {
                    sb.append(" " + rightOfTitle);
                }
            } else {
                if (leftOfTitle != null && contextTokens.indexOf(leftOfTitle) == -1) {
                    sb.append(leftOfTitle);
                }
                append(contextTokens, matchingTrigger, leftOfTitle, rightOfTitle, sb);

                sb.append(" " + matchingTrigger);


            }
            //System.out.println("matchingTrigger " + matchingTrigger + ", left " + matchedTokenOnLeftSide + ", Context '" + context + "': '" + sb + "', contextTokens " + contextTokens);
            System.out.println(sb);
        }
        
    }
}





def context_pruning(contexts, triggers):
    """
    Prunes contexts based on trigger words and prints the 
    results.
    """
    def pruned(context,trigger):
        try:
            words = context.split()
            i = words.index('-TITLE-')
            j = words.index(trigger)
            if i > j: # token on the left
                print ' '.join(words[j:i+2])
            else:     # token on the right
                print ' '.join(words[i-1 if i > 0 else 0:j+1])
            return True
        except:
            return False
        
    for context in contexts:
        for trigger in reversed(triggers):
            if pruned(context,trigger):
                break


class MyClass {
    public static void context_pruning(String[] contexts, String[] triggers) {
        
        // O(context.length * triggers.length)
        
        for (String s : contexts)
        {
            String[] toks = s.split(" +");
            
            // for each trigger
            boolean doneContext = false;
            for (int trig = triggers.length - 1; trig >= 0 && !doneContext; trig--)
            {
                boolean foundTrigger = false;
                boolean foundTitle = false;
                int titleIndex = 0;
                int trigIndex = 0;
                    
                // for each bit of the context
                for (int i = 0; i < toks.length && (!foundTrigger || !foundTitle); i++)
                {
                    if (toks[i].equals("-TITLE-")) 
                    {
                        titleIndex = i;
                        foundTitle = true;
                    }
                    else if (toks[i].equals(triggers[trig]))
                    {
                        trigIndex = i;
                        foundTrigger = true;
                    }
                }
                if (foundTrigger)
                {         
                    doneContext = true;
                    if (trigIndex < titleIndex)
                    {
                        // left side
                        System.out.println(makeString(toks, trigIndex, Math.min(titleIndex+2, toks.length)));
                    }
                    else
                    {
                        // right side
                        System.out.println(makeString(toks, Math.max(titleIndex-1, 0), trigIndex+1));   //need trigIndex + 1 so that trigIndex is inclusive                         
                    }
                }
            }
        }
    }
    
    public static String makeString(String[] a, int start, int end)
    {
        String str = "";
        for (int i = start; i < end; i++) str += a[i] + " ";
        return str.trim();
    }
    public static String makeString(String[] a)
    {
        return makeString(a, 0, a.length);
    }
}





















Challenge: Fast power

Searching for a string in a large data store by simply comparing characters would take ages or a huge amount of computing power. We need a way to do it fast!

The first step to building a fast search algorithm is to encode the data in a format that makes search efficient.

A critical operation in the encoding process which we’ll get familiar with a bit later is the exponentiation of integer numbers.

Given a list of pairs of integers (a,b)

Your task is to

    * write a function that prints to the standard output (stdout) for each pair the result of (ab) modulo 4211 (one per line)

Note that your function will receive the following arguments:

    * a
          o which is an array of integers giving the first element (a) of each pair
    * b
          o which is an array of integers giving the second element (b) of each pair

The ith pair is defined by a[i] and b[i].

Data constraints

    * the length of a, b arrays will not exceed 10000
    * elements of a, b arrays are integer numbers in the [0, 50000]

Efficiency constraints

    * your function is expected to print the requested result and return in less than 2 seconds
    * make sure you don't use any methods that do significant work for you (e.g. pow() in Python)

Example
Input   Output

a: 41619, 169, 29227, 13232

b: 6, 5, 7, 8
   

3226
3461
2507
2597 


http://homepages.math.uic.edu/~leon/cs-mcs401-s08/handouts/fastexp.pdf 






#include <iostream>
#include <vector>

using namespace std;

unsigned mod_pow(unsigned num, unsigned pow, unsigned mod)
{
    unsigned test;
    for(test = 1; pow; pow >>= 1)
    {
        if (pow & 1)
            test = (test * num) % mod;
        num = (num * num) % mod;
    }

    return test;
}

void fast_power(const vector<int> &a, const vector<int> &b) {
        int size = a.size();
    
        for (int i = 0; i < size; i++) {
            int total = mod_pow(a[i], b[i], 4211);
/*            
            int power = b[i];
            
            for (int j = 0; j < power; j++) {
                total = (total * a[i]) % 4211;
            }
*/

            cout << total << "\n";
        }
    
}





Peter Norvig solved Fast power in Python 
def fast_power(a, b):
    for (ai, bi) in zip(a, b):
        print powmod(ai, bi, 4211)
        
def powmod(a, b, m):
    "Return a**b mod m"
    if b == 0: return 1
    if b == 1: return a % m
    x = powmod(a, b//2, m)**2 % m
    if b % 2 == 0: return x
    return (x * a) % m










Challenge: Hash String

Now let’s solve the problem of encoding. As we mentioned previously, searching by simply comparing characters takes ages - so how can we speed up those comparisons?

Comparisons can be conducted faster if we do them on numbers rather than characters. So, we’ll just represent the characters as numbers and compare them as if they’re numbers.

During this challenge you’ll implement a way to encode (i.e: hashing) the characters into numbers.

Consider the string S = s0s1s2..sm-1, we define the hash value of S in the following way:

hash(S) = (a0 * 10m-1 + a1 * 10m-2 + … am-1 * 100) modulo 104677

where ai is the ASCII value of character si in the given string.

Given two strings S and T

Your task is to

    * write a function that prints to the standard output (stdout) how many substrings from T have the same length with S and also the same hash value
    * a substring is a sequence of consecutive characters from a given string

Note that your function will receive the following arguments:

    * s
          o which is the string "S" described above
    * t
          o which is the string "T" described above

Data constraints

    * the size of the S string will not exceed 200,000 characters
    * the size of the T string will not exceed 6,000,000 characters

Efficiency constraints

    * your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

s: "ab"

t: "cab bac abab"
   

3









Relative sort

Given an array of integer numbers your task is to print to the standard output (stdout) the initial array, but sorted in a special way:

    all negative numbers come first and their relative positions according to the initial array do not change
    the same with the positive integers, but they come last

Expected complexity: O(N) time, extra memory O(1)

Example input:
-5 2 1 -2 3

Example output:
-5 -2 2 1 3


import java.util.*;
// minor improvement is to shift positive numbers as we iterate, i.e., if previous number and current number is positive
// then move previous number to current positive number and save current positive number
class MyClass2 {
  public static void relative_sort(Integer[] v) {
    int lastPositiveNdx = -1;
    for (int i=0; i<v.length; i++) {
      int n = v[i];
      if (n < 0) {
        if (lastPositiveNdx >= 0) {
          int last = lastPositiveNdx;
          for (int j=i; j>lastPositiveNdx; j--) {
            v[j] = v[j-1];
            last = j;
          }
          v[lastPositiveNdx] = n;
          lastPositiveNdx = last;
        }
      } else if (lastPositiveNdx < 0) {
        lastPositiveNdx = i;
      }
    }
    for (int i=0; i<v.length; i++) {
      System.out.println(v[i]);
    }
  }


  public static boolean equals(Integer[] a1, Integer[] a2) {
      if (a1.length != a2.length) {
          return false;
      }
      for (int i=0; i<a1.length; i++) {
          if (!a1[i].equals(a2[i])) {
              return false;
          }
      }
      return true;
  }

  public static void main(String[] args) {
      /*
    Integer[] v1 = new Integer[] {-5, 2, 1, -2, 3};
    relative_sort(v1);
    if (!equals(v1, new Integer[] {-5, -2, 2, 1, 3})) {
        System.out.println("bad result1");
    }
    */
    Integer[] v2 = new Integer[] {2,-5,6,-1,-4,3};
    relative_sort(v2);
    if (!equals(v2, new Integer[] {-5, -1, -4, 2, 6, 3 })) {
        System.out.println("bad result2");
    }
  }
}





Majority number

Given an array of integer numbers your task is to print to the standard output (stdout) the majority number.

One number is considered majority if it occurs more than N / 2 times in an array of size N.

Note: If no number is majority then print "None"

Expected complexity: O(N) time, O(1) memory

Example input:
1 1 2 3 4 1 6 1 7 1 1

Example output:
1

Example input:
1 2 2 3

Example output:
None



import java.util.*;

class MyClass2 {
    public static void majority(Integer[] v) {
      Map<Integer, Integer> counts = new HashMap<Integer, Integer>();
      int max = -1;
      for (int i=0; i<v.length; i++) {
        Integer count = counts.get(v[i]);
        if (count == null) {
          count = 1;
        } else {
          count++;
        }
        counts.put(v[i], count);

        if (count > v.length/2) {
          max = v[i];
        }
      }
      if (max != -1) {
        System.out.println(max);
      }  else {
          System.out.println("None");
      }
    }

  public static void main(String[] args) {
    //majority(new Integer[] { 1, 1, 2, 3, 4, 1, 6, 1, 7, 1, 1});
    // majority(new Integer[] { 1, 2, 2, 3});
    majority(new Integer[] { 870,18,18,18,117,385,18,18 });
  }
}


Other solutions====


import java.util.Arrays;

class MyClass {
    public static void majority(Integer[] v) {
        int count = 1;
        int currentIndex = 0;
        for (int i = 1 ; i < v.length; i++) {
            if (v[i] == v[currentIndex]) {
                count++;
            } else {
                count--;
            }
            if (count == 0) {
                currentIndex = i;
                count = 1;
            }
        }
        int candidate = v[currentIndex];
        count = 0;
        for (Integer i: v) {
            if (i == candidate) {
                count++;
            }
        }
        
        if (count > v.length / 2) {
            System.out.println(candidate);
        } else {
            System.out.println("None");
        }
    }
}




class MyClass {
    public static void majority(Integer[] v) {
        int val = 0;
        int votes = 0;
        
        for (int i = 0; i < v.length; i++){
            if (votes == 0){val = v[i];}
            votes += (v[i] == val ? 1 : -1);
        }
        
        System.out.println(votes > 0 ? val : "None");
    }
}



Selection

Given an array with N integer numbers your task is to print to the standard output (stdout) the smallest K numbers among them.

Note: In a real world scenario N is expected to be the order of millions and K the order of hundreds

Expected complexity: lower than O(NlognN)

Example input:
K = 3
V = 9 1 3 7 2 2

Example output:
9 7 3

Example input:
K = 2
V = 1 2 8 7 3 3 1

Example output:
7 8




import java.util.*;

class MyClass2 {
  public static void select_numbers(Integer[] v, Integer k) {
    for (int i=0; i<k; i++) {
      int minIndex = i;
      int minValue = v[i];
      for (int j=i+1; j<v.length; j++) {
        if (v[j] < minValue) {
          minIndex = j;
          minValue = v[j];
        }
      }
      int t = v[i];
      v[i] = v[minIndex];
      v[minIndex] = t;
    }
    for (int i=0; i<k && i<v.length; i++) {
      System.out.println(v[i]);
    }
  }

  public static void main(String[] args) {
    select_numbers(new Integer[] { 9, 1, 3, 7 , 2, 2}, 3);
  }
}


Find Missing number from 1 to N

import java.util.*;

public class MissingNumber {
  public static void find_missing_number(Integer[] v) {
    BitSet found = new BitSet(v.length);
    for (int n : v) {
      found.set(n);
    }
    for (int i=1; i<=v.length+1; i++) {
      if (!found.get(i)) System.out.println(i);
    }
  }
  public static void main(String[] args) {
    find_missing_number(new Integer[] {5, 4, 1, 2});
  }

}

other solutions
 
class MyClass {
    public static void find_missing_number(Integer[] v) {
        int sum = 0;
        for (int n : v)
            sum += n;
        
        System.out.println((v.length+1) * ((v.length+1) + 1 ) / 2- sum);
        
    }
}


class MyClass {
    public static void find_missing_number(Integer[] v) {
        long e = (v.length + 1) * (v.length + 2) / 2;
        long s = 0;

        for (int i = 0; i < v.length; ++i) {
            s += v[i];
        }
        
        System.out.println(e - s);
    }
}



class MyClass {
    public static void find_missing_number(Integer[] v) {
       int n = v.length + 1;
        int expectedSum = (n * (n + 1)) / 2;
        int runningSum = 0;
        for(int x = 0; x < v.length; x++) {
            runningSum += v[x];
        }
      
        
        System.out.println(expectedSum - runningSum);
    }
}



import java.util.*;

/*
 *
 *Given an array A your tastk is to print in ascending order 4 distinct 0-based indexes of elements in the array that add up to a sum S, if such indexes exist.
 * If there are multiple solutions please print the lowest one according to the lexicographical order

Example input:
A = 3 2 1 4 5 7 6 9 7 8
S = 30

Example output:
5 6 7 9

*/

class TupleSum {
  public static void tuple_sum(Integer[] a, Integer s) {
    for (int i=0; i<a.length; i++) {
      for (int j=0; j<a.length; j++) {
        for (int k=0; k<a.length; k++) {
          for (int l=0; l<a.length; l++) {
            if (i != j && i != k && i != l && j != k && j != l && k != l) {
              if (a[i] + a[j] + a[k] + a[l] == s) {
                System.out.println(i + "\n" + j + "\n" + k + "\n" + l);
                return;
              }
            }
          }
        }
      }
    }
  }

  public static void main(String[] args) {
    tuple_sum(new Integer[] {3,2,1,4,5,7,6,9,7,8}, 30);
    //5 6 7 9
    //tuple_sum(new Integer[] {3,2,1,4,5,7,6,9,8}, 30);
    //5 6 7 8
  }
}



Type ahead


The Typeahead feature allows you to quickly search people while writing a tweet on Twitter.

How would you implement the Typeahead feature for the scenario described below?

Given a big list of user names and a list of strings representing queries

Your task is to

    write a function that prints to the standard output (stdout) for each query the user name that matches the query
    if there are multiple user names matching the query please select the one that is the smallest lexicographically
    all string matches must be case insensitive
    if no match is found for a given query please print "-1"

Note that your function will receive the following arguments:

    usernames
        which is an array of strings representing the user names
    queries
        which is an array of strings representing the queries described above

Data constraints

    the length of the array above will not exceed 100,000 entries
    each name or query string will not exceed 30 characters

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

names: ["james", "jBlank"]

queries: ["j", "jm", "jbl", "JB"]
  

james
-1
jBlank
jBlank

import java.util.*;
import java.io.*;

class TypeAhead {
  public static void typeahead(String[] usernames, String[] queries) {
    Map<String, String[]> lookup = new HashMap<String, String[]>();
    for (String u : usernames) {
      String lu = u.toLowerCase();
      for (int i=0; i<u.length(); i++) {
        String prefix = lu.substring(0, i+1);
        String[] val = lookup.get(prefix);
        if (val == null) {
          val = new String[] {u, lu};
          lookup.put(prefix, val);
        } else {
          if (val[1].compareTo(lu) > 0) {
            val[0] = u;
            val[1] = lu;
          }
        }
      }
    }
    for (String q : queries) {
      String[] matched = lookup.get(q.toLowerCase());
      if (matched == null) {
        System.out.println("-1");
      } else {
        System.out.println(matched[0]);
      }
    }
  }
  public static void main(String[] args) throws Exception {
      /*
      typeahead(new String[] {"james", "jBlank"}, new String[] {"j", "jm", "jbl", "JB"});
      */
      BufferedReader in = new BufferedReader(new FileReader("type.dat")); 
      String[] usernames = in.readLine().replaceAll("\"", "").split(",");
      String[] queries = in.readLine().replaceAll("\"", "").split(",");
      typeahead(usernames, queries);
  }
}
other solutions 
import java.util.Arrays;
import java.util.LinkedList;
class MyClass {
    public static void typeahead(String[] usernames, String[] queries) {
        int[] sizes = new int[26]; // 
        String[][] buckets = buckets(usernames, sizes);
        /*
        for(int i = 4; i < 5 && i < buckets.length; i++){
            printBucket(buckets[i]);
        } // */
        for(int i = 0; i < queries.length; i++){
            String query = queries[i].toUpperCase();
            int q = query.charAt(0) - 'A';
            print(buckets[q], query);
        }
    }
      private static String[][] buckets(String[] usernames, int[] sizes){
        LinkedList<String>[] buckets = new LinkedList[26];
        for(int i = 0; i < buckets.length; i++){
            buckets[i] = new LinkedList<String>();
            sizes[i] = 0;
        }
        for(int i = 0; i < usernames.length; i++){
            String word = usernames[i].toUpperCase() + "-" + usernames[i];
            int bucket = word.charAt(0) - 'A';
            buckets[bucket].add(word);
            sizes[bucket]++;
        }
        String[][] array = new String[26][];
        for(int i = 0; i < 26; i++){
            array[i] = new String[sizes[i]];
            buckets[i].toArray(array[i]);
            Arrays.sort(array[i]);
        }
        return array;
    }
    //private static void print(LinkedList<String> list, String query){
    private static void print(String[] list, String query){
        boolean printed = false;
        for( String w : list){
            if(w.startsWith(query)){
                System.out.println(w.split("-")[1]);
                printed = true;
                break;
            }
        }
        if(!printed){
            System.out.println("-1");
        }
    }
    /*private static void printBucket(String[] bucket){
        for(String w : bucket){
                System.out.print(w);
                System.out.print("\t");
        }
        if(bucket.length > 0){
            System.out.println("");
        }
    }*/
}

Tweets per second

Japan Castle in the Sky airing broke a Twitter record on August 3, 2013. At one point during the classic anime movie showing, people submitted 143,199 tweets per second.

This particular spike was about 25 times greater than Twitter’s steady state.

Given an array of integers representing the number of tweets recorded every second and an integer value K

Your task is to

    write a function that prints to the standard output (stdout) the highest number of tweets recorded between each second in the array and the past K seconds before it

Note that your function will receive the following arguments:

    tps
        which is an array of integers representing the number of tweets recorded every second
    k
        which is the integer number mentioned above

Data constraints

    the length of the array above will not exceed 500,000 numbers

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

tps: 6, 9, 4, 7, 4, 1

k: 3
  

6
9
9
9
7
7
Also found in:




/*
Tweets per second

Japan Castle in the Sky airing broke a Twitter record on August 3, 2013. At one point during the classic anime movie showing, people submitted 143,199 tweets per second.

This particular spike was about 25 times greater than Twitter’s steady state.

Given an array of integers representing the number of tweets recorded every second and an integer value K

Your task is to

    write a function that prints to the standard output (stdout) the highest number of tweets recorded between each second in the array and the past K seconds before it

Note that your function will receive the following arguments:

    tps
        which is an array of integers representing the number of tweets recorded every second
    k
        which is the integer number mentioned above

Data constraints

    the length of the array above will not exceed 500,000 numbers

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

tps: 6, 9, 4, 7, 4, 1

k: 3
  

6
9
9
9
7
7
*/



import java.math.*;

class Tweets {
  public static void tweets_per_second(Integer[] tps, Integer k) {
    for (int i=0; i<tps.length; i++) {
      int max = tps[i];
      for (int j=Math.max(i-k+1, 0); j<i; j++) {
        max = Math.max(max, tps[j]);
      }
      System.out.println(max);
    }
  }
  public static void main(String[] args) throws Exception {
      tweets_per_second(new Integer[] {6, 9, 4, 7, 4, 1}, 3);
      /*
      BufferedReader in = new BufferedReader(new FileReader("type.dat")); 
      String[] usernames = in.readLine().replaceAll("\"", "").split(",");
      String[] queries = in.readLine().replaceAll("\"", "").split(",");
      typeahead(usernames, queries);
      */
  }
}


other solutions 

import java.util.*;
class MyClass {
    public static void tweets_per_second(Integer[] tps, Integer k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(k, new Comparator<Integer>() {
            @Override public int compare(Integer i1, Integer i2) {
                 return i2 - i1;   
            }
        });
        for (int i=0; i < k; ++i) {
            pq.add(tps[i]);
            System.out.println(pq.peek());
        }
        for (int i=k; i < tps.length; ++i) {
            pq.add(tps[i]);
            pq.remove(tps[i-k]);
            System.out.println(pq.peek());
        }
    }
}






/*
 *
Price experiment

Uber is a company based in San Francisco, California that makes a mobile application that connects passengers with drivers of luxury vehicles for hire.

Uber is doing experiments to better understand the relationship between price and demand for rides. One hypothesis is that lower prices will show an increase in demand for cars.

Their goal is to find the cost/demand point that is best for everyone.

Experimental data will show that the relation between the price discount and the uber revenue can be approximated by a mathematical function. Lets consider the following function:

y = 1/2 ((-3x^2 + Ax + B) - x - 1)

where

    x represents the discount,
    y represents the uber revenue and
    A, B are two constant positive integers

The relation described above has a shape similar to the one shown below:

Given the two positive integer numbers A and B

Your task is to

    write a function that prints to the standard output (stdout) the discount value x that maximizes uber revenue y
    please print the found value x truncated to two decimal places without rounding.

Note that your function will receive the following arguments:

    a
        the positive integer number A
    b
        the positive integer number B

Data constraints

    the values of a, b constants will not exceed 2000

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

a: 250

b: 400
    

20.04
*/

import java.util.*;
import java.io.*;


public class Pricing {
  public static void uber_price(Integer a, Integer b) {
      // derivative = 
      // L = A - 6x 
      // M = 2 * Sqrt(x(A-3x)+B)
      // (1/2) * (L / M - 1)
      // root 
      // when A^2 + 12B != 0
      //    x = 1/12 * (2A - sqrt(A^2 + 12B))
      //
    double x = 1.0 / 12.0 * (2.0F * a - Math.sqrt(a*a + 12.0 * b));
    String val = String.format("%.3f", x);
    System.out.println(val.substring(0, val.length()-1));
  }
  public static void main(String[] args) throws Exception {
      uber_price(250, 400);
  }
}


Other solutions 


class MyClass {
    public static void uber_price(Integer a, Integer b) {
        double d = ((2 * a) - Math.sqrt(a * a + (12 * b))) / 12.0;
        int i = (int)(d * 100.0);
        System.out.println(String.format("%.2f", i / 100.0f));
    }
}






Neighbourhood

Uber needs to connect a rider with a car as fast as possible. To achieve that, the system needs to accurately predict demand to make sure you get a car when you want one. Predicting demands requires knowledge about the locations from which most orders are likely to occur.

Given a neighbourhood represented as the coordinates of a convex polygon and a list of trip destinations

Your task is to

    write a function that prints to the standard output (stdout) the number of trips that ended in the given neighbourhood

Note that your function will receive the following arguments:

    neighbourhood
        which is an array of strings representing the coordinates of the polygon
        the convex polygon coordinates are presented in clockwise order
        each string contains the x,y coordinates of one vertex, separated by comma
    trips
        which is an array of strings representing the coordinates of the trips destinations
        each string contains the x,y coordinates of one destination, separated by comma

Data constraints

    the length of the arrays above will not exceed 100,000 entries
    all the coordinates values, for both the polygon and trip destinations, will be integer numbers in the [0, 10000] range

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output
neighbourhood: ["1,3","4,5","3,1"]
trips: ["1,1","2,3","3,3","4,2"]  2

Explanation:

The only trips that ended in the neighbourhood are (2,3) and (3,3).



import java.util.Arrays;
import java.util.List;

class MyClass {

    public static void count_requests(Integer[] requests, Integer[] pro_start, Integer[] pro_end) {
        Arrays.sort(requests);
        List<Integer> list = Arrays.asList(requests);
        for (int i = 0; i < pro_start.length; i++) {
            int startIndex = Arrays.binarySearch(requests, pro_start[i]);
            int endIndex = Arrays.binarySearch(requests, pro_end[i]);
            startIndex = (startIndex >= 0) ? list.indexOf(pro_start[i]) - 1 : -startIndex - 2;
            endIndex = (endIndex >= 0) ? list.lastIndexOf(pro_end[i]) : -endIndex - 2;
            System.out.println(endIndex - startIndex);
        }
    }
}




import java.util.Arrays;
class MyClass {
    public static class Req implements Comparable<Req>{
        int start;
        int end;
        public Req(int start, int end){
            this.start=start;
            this.end=end;
        }
        @Override
        public int compareTo(Req other){
            if(other.end==this.end){
                return this.start-other.start;
            }
            return this.end-other.end;
        }
    }
    public static void schedule_requests(Integer[] req_start, Integer[] req_end) {
        // Write your code here
        // To print results to the standard output please use System.out.println
        // Example: System.out.println("Hello world!");
        Req[] r = new Req[req_start.length];
        for(int i=0;i<r.length;i++){
            r[i]=new Req(req_start[i],req_end[i]);
        }
        Arrays.sort(r);
        int time=0;
        int completed=0;
        for(int i=0;i<r.length;i++){
            if(r[i].start>=time){
                time=r[i].end;
                completed++;
            }
        }
        System.out.println(completed);
        
    }
}



