 Every week the number of unique visitors grow with 7% compared to the previous week.

Giving an integer number N representing the number of unique visitors at the end of this week and an integer number W

Your task is to

    write a function that prints to the standard output (stdout) the number of unique visitors we are going to have after W weeks
    please round the final result downwards to the nearest integer (e.g both 7.1 and 7.9 are rounded to 7)

Note that your function will receive the following arguments:

    n
        which is an integer representing the number N described above
    w
        which is an integer representing the number W described above

Data constraints

    the value for N will not exceed 10000
    the value for W will not exceed 50


class MyClass {
    public static void compute_prediction(Integer n, Integer w) {
        double sum = n;
        for (int i=0; i<w; i++) {
            sum = sum * 1.07;
        }
        
        int result = (int) Math.floor(sum);
        System.out.println(result);
        
    }
}

Your task is to

    write a function that prints to the standard output (stdout) the number of unique possible configurations (as, bs, cs) which can be used to serve exactly N visitors
    as represents the number of users from location a we choose to serve
    bs represents the number of users from location b we choose to serve
    cs represents the number of users from location c we choose to serve

Note that your function will receive the following arguments:

    a
        which is an integer representing the number of users from location a
    b
        which is an integer representing the number of users from location b
    c
        which is an integer representing the number of users from location c
    n
        which is an integer representing the number of users our servers can serve

Data constraints

    the values for a, b, c will be in the [0 .. 100] range
    n will always be smaller than the sum of a, b, and c


class MyClass {
    public static void count_configurations(Integer a, Integer b, Integer c, Integer n) {
        int matched = 0;
        for (int i=0; i<=a; i++) {
            for (int j=0; j<=b; j++) {
                for (int k=0; k<=c; k++) {

                    if (i+j+k == n) {
                        matched++;
                    }
                }
            }
        }      
        System.out.println(matched);
    }
}



 Given an array with all final grades for a course

Your task is to

    write a function that finds the highest grade and prints this grade to standard output (stdout)

Note that your function will receive the following arguments:

    grades
        which is the list of grades, represented as integer numbers

Data constraints

    the length of the array given as input will not exceed 1000 elements



import java.util.*;
class MyClass {
    public static void max_grade(Integer[] grades) {
        Arrays.sort(grades);
        System.out.println(grades[grades.length-1]);
        
    }
}


 Given an array with all final grades for a course and the minimum grade that a student needs to have in order to pass the course

Your task is to

    write a function that counts the number of students that passed and prints this number to standard output (stdout)

Note that your function will receive the following arguments:

    grades
        which is the list of grades, represented as integer numbers
    min_grade
        which is the minimum grade that a student can get, so that he passes the course

Data constraints

    the length of the array given as input will not exceed 1000 elements

Example
Input   Output

grades: 1, 2, 8, 4, 5, 8, 3
min_grade: 5
    
3

class MyClass {
    public static void count_successful_students(Integer[] grades, Integer min_grade) {
        int matched = 0;
        for (Integer grade : grades) {
            if (grade >= min_grade) {
                matched++;
            }
        }
        System.out.println(matched);
    }
}


 An easy way to understand how well the students performed at this years course is to compute the average of their final grades. If it is higher that the average for last year, that means the course was easier than last year.

Given an array with all final grades for a course

Your task is to

    write a function that computes the average of all the grades in the array and prints this number to standard output (stdout)
    the result must be rounded downwards to the nearest integer (e.g. both 7.1 and 7.9 are rounded to 7)

Note that your function will receive the following arguments:

    grades
        which is the list of grades, represented as integer numbers

Data constraints

    the length of the array given as input will not exceed 1000 elements


class MyClass {
    public static void compute_average_grade(Integer[] grades) {
        int sum = 0;
        for (Integer grade : grades) {
            sum += grade;
        }
        System.out.println(sum/grades.length);
    }
}



 Students are graded for their activity in each lab session.

It is expected that a students performance improves in time, which means that he should always receive a grade equal to or higher than the grade he received in the previous lab.

Given an array with the lab grades of a student

Your task is to

    write a function that checks whether the grades received by each student are in ascending order
    your function must print to standard output (stdout):
        1 if the grades are in ascending order (e.g. 1, 3, 3, 7)
        0 if the grades are not in ascending order (e.g. 1, 3, 7, 3)

Note that your function will receive the following arguments:

    grades
        which is an array containing the grades of the student

Data constraints

    the length of the array given as input will not exceed 1000 elements


class MyClass {
    public static void is_sorted(Integer[] grades) {
        for (int i=1; i<grades.length; i++) {
            if (grades[i-1] > grades[i]) {
                System.out.println(0);
                return;
            }
        }        
        System.out.println(1);
    }
}


 A student's performance in lab activities should always improve, but that is not always the case.

Since progress is one of the most important metrics for a student, lets write a program that computes the longest period of increasing performance for any given student.

For example, if his grades for all lab activities in a course are: 9, 7, 8, 2, 5, 6, 8, 7 then the longest period would be 4 consecutive labs (2, 5, 6, 8).

Given an array with the lab grades of a student

Your task is to

    write a function that computes and prints to standard output (stdout) the longest period of increasing performance for the student that has these grades

Note that your function will receive the following arguments:

    grades
        which is an array containing the grades of the student

Data constraints

    the length of the array given as input will not exceed 1000 elements


class MyClass {
    public static void longest_improvement(Integer[] grades) {
        int matched = 1;
        int max = -1;
        for (int i=1; i<grades.length; i++) {
            if (grades[i-1] <= grades[i]) {
                matched++;
                max = Math.max(matched, max);
            } else {
                matched = 1;
            }
        }
        System.out.println(max);
    }
}


 After an exam all the students are graded and sorted by their grades.

In some cases, students talk to the professor and conclude that one of the tougher problem statements in the exam was unclear and the teacher decides to remove its contribution towards the final grade.

Since its just one of many challenges, the sorted list of students wont change much - only a few students might change their order.

How do we implement an efficient algorithm that sorts a list of numbers that are almost sorted? Bubble sort is the perfect one for this specific case:

    bubblesort(A):
    repeat
        changed = false
        for i = 1 to length(A) - 1
            if A[i - 1] > A[i]
                swap A[i - 1], A[i]
                changed = true
    until not changed
  

Given an array of integer numbers

Your task is to

    implement the bubblesort algorithm to sort the array in ascending order and print the sorted elements to standard output (stdout), one per line

Note that your function will receive the following arguments:

    numbers
        which is the array of integer numbers that needs to be sorted

Data constraints

    the length of the array given as input will not exceed 1000 elements


import java.util.*;
class MyClass {
    public static void sort_students(Integer[] numbers) {
        Arrays.sort(numbers);
        for (Integer n : numbers) {
            System.out.println(n);
        }
        
    }
}



 A teacher wants to compare the performance of two students. To understand them better, hes looking at all the other courses they took, but its hard to spot the common courses just from a glance.

Given two arrays that contain the course IDs of two different students

Your task is to

    write a function that prints to standard output (stdout) all the course IDs that are contained in both arrays, sorted in ascending order, one per line

Note that your function will receive the following arguments:

    courses1
        which is the list of course IDs for the first student
    courses2
        which is the list of course ids for the second student

Data constraints

    the length of the array given as input will not exceed 1000 elements



import java.util.*;
class MyClass {
    private static boolean exists(Integer[] arr, int n) {
        for (Integer i : arr) {
            if (i.equals(n)) {
                return true;
            }
        }
        return false;
    }
    public static void get_common_courses(Integer[] courses1, Integer[] courses2) {
        List<Integer> list = new ArrayList<Integer>();
        for (int i=0; i<courses1.length; i++) {
            if (exists(courses2, courses1[i])) {
                list.add(courses1[i]);
            }
        }
        
        Collections.sort(list);
        for (Integer n : list) {
            System.out.println(n);
        }
    }
}

 common operation with text editors is selecting a block of text for further manipulation. Lets see how an editor extracts the characters between two given positions in a string.

Given a string S and two integer numbers p1, p2

Your task is to

    write a function that extracts all the characters between positions p1 and p2 in the given string and prints these characters to standard output (stdout)

Note that your function will receive the following arguments:

    s
        which is the string from which you must extract the specified characters
    p1
        which is the position of the left-most character that you must extract
    p2
        which is the position of the right-most character that you must extract

Data constraints

    the string will contain at most 1000 characters

class MyClass {
    public static void select_substring(String s, Integer p1, Integer p2) {
        StringBuilder sb = new StringBuilder();
        for (int i=p1-1; i<p2 && i<s.length(); i++) {
            sb.append(s.charAt(i));
        }
        System.out.println(sb);
    }
}



 Another common operation is deleting characters starting from the position of our cursor in the editor.

Given a string S, a position in this string P and a number N

Your task is to

    write a function that deletes N characters from the string S, starting from position P
    your function must print the newly formed string to standard output (stdout)

Note that your function will receive the following arguments:

    s
        which is the string from which we must delete the specified characters
    p
        which is the position in the string from which we must start deleting characters
    n
        which is the number of characters that must be deleted

Data constraints

    the string will contain at most 1000 characters

class MyClass {
    public static void remove_substring(String s, Integer p, Integer n) {
        StringBuilder sb = new StringBuilder();
        for (int i=0; i<s.length() && i< p-1; i++) {
            sb.append(s.charAt(i));
        }
        for (int i=p+n-1; i<s.length(); i++) {
            sb.append(s.charAt(i));
        }
        System.out.println(sb);        
    }
}




 When writing text we frequently use the copy and paste commands. Lets see how an editor implements the paste command.

Given two strings S1 and S2 and an integer number P

Your task is to

    write a function that inserts S2 into S1 starting with the position P in S1 and then prints the newly formed string S1 to standard output (stdout)

Note that your function will receive the following arguments:

    s1
        which is the string in which we must make the insertion
    s2
        which is the string that needs to be inserted
    p
        which is the position in s1 where s2 must be inserted

Data constraints

    the strings will contain at most 1000 characters



class MyClass {
    public static void copy_string(String s1, String s2, Integer p) {
        StringBuilder sb = new StringBuilder();
        for (int i=0; i<s1.length() && i< p; i++) {
            sb.append(s1.charAt(i));
        }
        sb.append(s2);
        for (int i=p; i<s1.length(); i++) {
            sb.append(s1.charAt(i));
        }
        System.out.println(sb);        
    }
}

 When writing an essay it is useful to know the total number of words that we have typed.

Let's define a word as any number of characters separated by spaces and commas. For example the string " one, ,two three,4," contains 4 words.

Given a string S

Your task is to

    write a function that counts the number of words in the given string and prints this number to standard output (stdout)

Note that your function will receive the following arguments:

    s
        which is the string for which you must count the number of words

Data constraints

    the string will contain at most 1000 characters



import java.util.*;
class MyClass {
    public static void count_words(String s) {
        StringTokenizer st = new StringTokenizer(s, " ,");
        int count = 0;
        while (st.hasMoreTokens()) {
            String next = st.nextToken();
            if (next.trim().length() > 0) {
                count++;
            }
        }
        System.out.println(count);
    }
}



 Some advanced code editors allow programmers to sort the words from a selected block of text. This is useful when we are polishing our code to make sure everything is readable and consistent.

Lets define a word as any number of characters separated by spaces and commas. For example the string " one, ,two three,4," contains 4 words.

Given a string S

Your task is to

    write a function that sorts all the words in the string alphabetically and prints them to standard output (stdout) in sorted order, one on each line

Note that your function will receive the following arguments:

    s
        which is the string from which you must extract and sort the words

Data constraints

    the string will contain at most 1000 characters

Example


import java.util.*;
class MyClass {
    public static void sort_words(String s) {
        StringTokenizer st = new StringTokenizer(s, " ,");
        List<String> words = new ArrayList<String>();
        while (st.hasMoreTokens()) {
            String next = st.nextToken().trim();
            if (next.length() > 0) {
                words.add(next);
            }
        }
        Collections.sort(words);
        for (String word : words) {
            System.out.println(word);
        }
    }
}



Given an integer number N

Your task is to

    write a function that prints to the standard output (stdout) the numbers from 1 to N (one per line) with the following restrictions
        for multiples of three print Fizz instead of the number
        for the multiples of five print Buzz instead of the number
        for numbers which are multiples of both three and five print FizzBuzz

Note that your function will receive the following arguments:

    n
        which is the integer number described above

Data constraints

    the maximum value of N will not exceed 1000

Efficiency constraints

    your function is expected to print the result in less than 2 seconds



class MyClass {
    public static void fizzbuzz(Integer n) {
        for (int i=1; i<=n; i++) {
            if (i % 3 == 0 && i % 5 == 0) {
                System.out.println("FizzBuzz");
            } else if (i % 3 == 0) {
                System.out.println("Fizz");
            } else if (i % 5 == 0) {
                System.out.println("Buzz");
            } else {
                System.out.println(i);
            }
        }
        
    }
}



As soon as a user inputs a query, the search engine must tokenize it - that means break it down into understandable tokens. A token is defined as a sequence of characters separated by white spaces and/or punctuation.

Given a string representing a user query and a set of punctuation characters

Your task is to

    write a function that prints to the standard output (stdout) all the tokens in the user query (one per line)

Note that your function will receive the following arguments:

    query
        which is a string giving the user query
    punctuation
        which is a string giving the punctuation characters that separate tokens

Data constraints

    the size of the query string will not exceed 1000 characters
    the size of the punctuation string will not exceed 10 characters

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example



import java.util.*;
class MyClass {
    public static void tokenize_query(String query, String punctuation) {
        StringTokenizer st = new StringTokenizer(query, punctuation + " ");
        List<String> words = new ArrayList<String>();
        while (st.hasMoreTokens()) {
            String next = st.nextToken().trim();
            if (next.length() > 0) {
                words.add(next);
            }
        }
        for (String word : words) {
            System.out.println(word);
        }        
    }
}



Stop words are tokens which are filtered out from queries because they add little value in finding relevant web pages.

Given a list of tokens that were obtained after the search engine tokenized the user query using your code from the previous task and a list of stopwords

Your task is to

    write a function that prints to the standard output (stdout) all the tokens in the user query that are not stop words (one per line)

Note that your function will receive the following arguments:

    query
        which is an array of strings giving the tokens in the user query
    stopwords
        which is an array of strings giving the stop words

Data constraints

    the length of the query array will not exceed 1000
    the length of the stopwords array will not exceed 1000
    all string comparisons are case-sensitive (i.e: Cool != cool)

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds



import java.util.*;
class MyClass {
    public static void remove_stopwords(String[] query, String[] stopwords) {
        List<String> result = new ArrayList<String>();    
        for (int i=0; i<query.length; i++) {
            boolean matched = false;
            for (int j=0; j<stopwords.length; j++) {
                if (query[i].equals(stopwords[j])) {
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                result.add(query[i]);
            }
        }
        for (String word : result) {
            System.out.println(word);
        }
    }
}


Stemming removes word suffixes to reduce inflected (or sometimes derived) words to their base or root form.

E.g. friendly is an inflection of friend. By stemming (in this case stemming means removing the suffix ly), friendly is reduced to friend.

Given a list of tokens and a list of suffixes

Your task is to

    write a function that prints to the standard output (stdout) all the tokens having their suffix removed if found in the list of suffixes (please print one token per line)
    for each token if there is more than one suffix that can be removed please choose the one that is the longest

Note that your function will receive the following arguments:

    tokens
        which is an array of strings giving the tokens described above
    suffixes
        which is an array of strings giving the suffixes described above

Data constraints

    the length of the tokens array will not exceed 1000
    the length of the suffixes array will not exceed 100
    all string comparisons are case-sensitive (i.e: Cool != cool)

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example



import java.util.*;
class MyClass {
    private static final Comparator<String> CMP = new Comparator<String>(){
        @Override
        public int compare(String o1, String o2) {  
            if (o1.length() > o2.length()) {
                return 1;
            } else if (o1.length() < o2.length()) {
                return -1;
            }
            return o1.compareTo(o2);
        }
    };
    public static void token_stemming(String[] tokens, String[] suffixes) {
        List<String> result = new ArrayList<String>();
        Arrays.sort(suffixes, CMP);
        for (int i=0; i<tokens.length; i++) {
            String word = tokens[i];
            for (int j=suffixes.length-1; j>=0; j--) {
                if (tokens[i].endsWith(suffixes[j])) {
                    word = word.substring(0, word.length()-suffixes[j].length());
                    break;
                }
            }
            result.add(word);
        }
        for (String word : result) {
            System.out.println(word);
        }        
    }
}



It's time to retrieve the web pages that match a user query.

Given a query as a list of tokens and a list of strings representing the content of each web page

Your task is to

    write a function that prints to the standard output (stdout) the number of web pages that contain all the given tokens in the same order.

Note that your function will receive the following arguments:

    query
        which is an array of strings giving the tokens in the user query
    pages
        which is an array of strings giving the content of each web page

Data constraints

    the length of the query array will not exceed 10
    the length of the pages array will not exceed 1000
    the length of any web page content will not exceed 1000
    all string comparisons are case-sensitive (i.e: Cool != cool)

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example


class MyClass {
    public static void search_query(String[] query, String[] pages) {
        int count = 0;
        for (int i=0; i<pages.length; i++) {
            int matched = 0;
            int index = 0;
            for (int j=0; j<query.length; j++) {
                int mndx = pages[i].indexOf(query[j], index);
                if (mndx != -1) {
                    index = mndx + query[j].length();
                    matched++;
                }
            }
            if (matched == query.length) {
                count++;
            }
        }
        System.out.println(count);
        
    }
}



Challenge: Context extraction

Considering the name of a book and the tweet mentioning it we define the context of the book as a sequence of tokens immediately preceding and immediately following the book name in the tweet.

    A token is defined as a sequence of characters that occur between white spaces.
    The size of the context is W tokens on each side (preceding and following the book name)

For example, having the book title "Beautiful Code", W=2 and the following tweet

"I read Beautiful Code and it was simply amazing"

the context is "I read -TITLE- and it"

Given a list of book titles, a list of tweets and W

Your task is to

    write a function that prints to the standard output (stdout) for each book all the contexts that can be extracted from the list of tweets (one per line in the same order with the tweets that generated those contexts)
    each context must be printed as a string formed by concatenating the tokens preceding the book title, the keyword "-TITLE-" (one white space on both sides) and the tokens following the book title
    please take into consideration the following constraints:
        A book title matches a tweet if all its tokens match a sequence of consecutive tokens in the tweet (e.g. "Beautiful Code" does not match "Beautiful A Code")
        If the number of available tokens preceding or following a book title is lower than W extract only those available.
        If a context is empty on both the left and the right side it must be ignored, otherwise it is considered valid

Note that your function will receive the following arguments:

    books
        which is an array of strings representing the book titles
    tweets
        which is an array of strings representing the tweets
    w
        which is an integer number as described above

Data constraints

    the length of the books array will not exceed 50
    the length of the tweets array will not exceed 10000

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example


class MyClass {
    public static void extract_contexts(String[] books, String[] tweets, Integer w) {
        for (int j=0; j<books.length; j++) {
            for (int i=0; i<tweets.length; i++) {
                int ndx = 0;
                StringBuilder sb = new StringBuilder();

                while ((ndx=tweets[i].indexOf(books[j], ndx)) != -1) {
                    String[] prefix = tweets[i].substring(0, ndx).split(" ");
                    for (int k=prefix.length-1, l=0; k >= 0 && l<w; k--, l++) {
                        String word = prefix[k].trim();
                        if (word.length() == 0) {
                            l--;
                            continue;
                        }
                        if (sb.length() > 0) {
                            sb.insert(0, " ");
                        }
                        
                        sb.insert(0, word);
                    }
                    sb.append(" -TITLE- ");
                    ndx += books[j].length();
                    String[] suffix = tweets[i].substring(ndx).split(" ");

                    for (int k=0, l=0; k < suffix.length && l<w; k++, l++) {
                        String word = suffix[k].trim();
                        if (word.length() == 0) {
                            l--;
                            continue;
                        }
                        sb.append(word);
                        if (k<suffix.length-1 && l<w-1) {
                            sb.append(" ");
                        }
                    }
                }
                final String result = sb.toString().trim();
                if (result.length() > 0) {
                    System.out.println(result);
                }
            }
        }
        
    }
}


Challenge: Trigger words

Lets consider a context that was extracted during the previous challenge:

Did you read -TITLE- on Kindle yesterday?

In this example, "read" and "Kindle" are trigger words. These types of words signal that theres a high likelihood of finding a book title in their vicinity.

A trigger word is a token that has two properties:

    it is frequent in the list of extracted contexts
    it is specific to the field of books

In order to identify trigger words we are going to assign a weight to each token. Lets call this weight: IDF ("inverse document frequency").

IDF(token) = log(N / num_contexts(token))

    N represents the total number of contexts we are working with
    num_contexts(token) represents the number of contexts that contain the given token
    log() represents the natural logarithm (base E) of a number.

Given a list of contexts and an integer number M

Your task is to

    write a function that prints to the standard output (stdout) the first M tokens having the highest IDF value (one per line)
    if there are more tokens having the same IDF value they must be sorted in lexicographical order

Note that your function will receive the following arguments:

    contexts
        which is an array of strings giving a list of contexts
        each context is a string of tokens containing the keyword "-TITLE-" (separated by spaces) which delimits the left side of the context and the right side of it
    m
        which is an integer number giving the number mentioned above

Data constraints

    the length of the contexts array will not exceed 1000
    the length of a context string will not exceed 1000 characters

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

contexts: "to read -TITLE- while in", "to buy -TITLE- while in school", "buy -TITLE-"

m: 2
    

read
school

Explanation

    In this example we are working with 3 contexts, so N = 3
    IDF("read") = log(3/1) = 1.09
    IDF("buy") = log(3/2) = 0.40



import java.util.*;
class MyClass {
    static int N;
    static class Info implements Comparable<Info> {        
        String token;
        int num_context;
        public Info(String token) {
            this.token = token;
            num_context = 1;
        }
        double idf() {
            return Math.log(N / num_context);            
        }
        @Override
        public int compareTo(Info other) {
            if (other.idf() < idf()) {
                return -1;
            } else if (other.idf() > idf()) {
                return +1;
            } else {
                return token.compareTo(other.token);
            }
        }
        @Override public String toString() {
            return token + ", N " + N + ", num " + num_context + ", idf " + idf() + "\n";
        }
    }
    public static void extract_trigger_words(String[] contexts, Integer m) {
        N = contexts.length;
        Map<String, Info> idfMap = new TreeMap<String, Info>();
        for (String c : contexts) {
            String[] arr = c.split(" ");
            Arrays.sort(arr);
            for (int i=0; i<arr.length; i++) {
                if (!arr[i].equals("-TITLE-")) {
                    Info info = idfMap.get(arr[i]);
                    if (info == null) {
                        idfMap.put(arr[i], new Info(arr[i]));
                    } else {
                        if (i > 1 && arr[i-1].equals(arr[i])) {
                            //skip
                        } else {
                            info.num_context++;
                        }
                    }
                }
            }
        }
        List<Info> idfList = new ArrayList<Info>(idfMap.values());
        Collections.sort(idfList);
        for (int i=0; i<m && i<idfList.size(); i++) {
            System.out.println(idfList.get(i).token);
        }
    }
}

Context pruning

Youve obtained the set of trigger words, congrats!

Its time to remove the tokens that are not useful in predicting a book title in their vicinity from each context. This operation is called pruning.

Pruning each context is done in the following fashion:

    select the token which is a trigger word and has the highest IDF (inverse document frequency)
    if none of the tokens is a trigger word then ignore the context
    if the token is on the left side of the context
        we keep the token and all tokens on its right
        for the right side of the context we keep only the first token (if exists)
    if the token is on the right side of the context
        we keep the token and all tokens on its left
        for the left side of the context we keep only the last token (if exists)

Considering the list of trigger words [Kindle, read] sorted in ascending order by their IDF, pruning the context: Did you read -TITLE- on Kindle yesterday? will produce the following result:

    read -TITLE- on

Given a list of contexts and a list of trigger words sorted in ascending order by IDF

Your task is to

    write a function that prunes the contexts and prints the results to the standard output (stdout)

Note that your function will receive the following arguments:

    contexts
        which is an array of strings giving a list of contexts
        each context is a string of tokens containing the keyword "-TITLE-" (separated by spaces) which delimits the left side of the context and the right side of it
    triggers
        which is an array of strings representing trigger words sorted in ascending order by IDF

Data constraints

    the length of the contexts array will not exceed 1000
    the length of a context string will not exceed 1000 characters
    the length of the triggers array will not exceed 1000
    the length of a trigger word will not exceed 100 characters

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

contexts: "to read -TITLE- while in", "to buy -TITLE- while in school", "buy -TITLE-"

triggers: "read", "school"
    

read -TITLE- while
buy -TITLE- while in school




import java.util.*;
class MyClass {
    
    private static void append(List<String> contextTokens, String matchingTrigger, String leftOfTitle,String rightOfTitle, StringBuilder sb) {
        boolean printedTitle = false;
        for (int i=0; i<contextTokens.size(); i++) {
            if (contextTokens.get(i).equals(matchingTrigger)) {
                continue;
            }
            if (sb.length() > 0) {
                sb.append(" ");
            }
            if (!printedTitle && rightOfTitle != null && contextTokens.get(i).equals(rightOfTitle)) {
                sb.append("-TITLE- ");
                printedTitle = true;
            }
            sb.append(contextTokens.get(i));
            if (!printedTitle && leftOfTitle != null && contextTokens.get(i).equals(leftOfTitle)) {
                sb.append(" -TITLE-");
                printedTitle = true;
            }
        }
        if (!printedTitle) {
            sb.append(" -TITLE-");
        }
    }
    private static boolean idfHigher(String matchingTrigger, String token, String[] triggers) {
        int matchingIdfIndex = -1;
        int tokenIdfIndex = -1;
        for (int i=0; i<triggers.length; i++) {
            if (triggers[i].equals(matchingTrigger)) {
                matchingIdfIndex = i;
            }
            if (triggers[i].equals(token)) {
                tokenIdfIndex = i;
            }
        }
        if (matchingIdfIndex == -1 || tokenIdfIndex == -1) {
            return false;
        }
        return matchingIdfIndex < tokenIdfIndex; // triggers are in asc IDF
    }
    public static void context_pruning(String[] contexts, String[] triggers) {
        for (String context : contexts) {
            String matchingTrigger = null;
            boolean matchedTokenOnLeftSide = true;
            String leftOfTitle = null;
            String rightOfTitle = null;
            List<String> contextTokens = new ArrayList<String>();
            List<String> tokensSinceMatchingToken = new ArrayList<String>();
            boolean foundTitle = false;
            for (String token : context.split(" ")) {
                if (token.equals("-TITLE-")) {
                    foundTitle = true;
                    if (matchingTrigger == null) {
                        contextTokens.clear();
                    }
                    continue;
                }
                //
                if (!foundTitle) {
                    leftOfTitle = token;
                } else if (rightOfTitle == null) {
                    rightOfTitle = token;
                }
                //
                for (String trigger : triggers) {
                    if (token.equals(trigger) && (matchingTrigger == null || idfHigher(matchingTrigger, token, triggers))) {
                        matchingTrigger = token;
                        if (foundTitle) {
                            matchedTokenOnLeftSide = false;
                        } else {
                            contextTokens.clear();
                            matchedTokenOnLeftSide = true;
                        }
                        for (String t : tokensSinceMatchingToken) {
                            if (contextTokens.indexOf(t) == -1) {
                                contextTokens.add(t);
                            }
                        }
                        tokensSinceMatchingToken.clear();
                    } else if ((matchingTrigger == null || !foundTitle) && !token.equals(matchingTrigger)) {
                        if (contextTokens.indexOf(token) == -1) {
                            contextTokens.add(token);
                        }
                    } else if (matchingTrigger != null && !token.equals(matchingTrigger) && tokensSinceMatchingToken.indexOf(token) == -1) {
                        tokensSinceMatchingToken.add(token);
                    }
                }
            }
            if (matchingTrigger == null) {
                // ignore 
                continue;
            }
            StringBuilder sb = new StringBuilder();
            if (matchedTokenOnLeftSide) {
                sb.append(matchingTrigger);
                append(contextTokens, matchingTrigger, leftOfTitle, rightOfTitle, sb);

                if (rightOfTitle != null && contextTokens.indexOf(rightOfTitle) == -1) {
                    sb.append(" " + rightOfTitle);
                }
            } else {
                if (leftOfTitle != null && contextTokens.indexOf(leftOfTitle) == -1) {
                    sb.append(leftOfTitle);
                }
                append(contextTokens, matchingTrigger, leftOfTitle, rightOfTitle, sb);

                sb.append(" " + matchingTrigger);


            }
            //System.out.println("matchingTrigger " + matchingTrigger + ", left " + matchedTokenOnLeftSide + ", Context '" + context + "': '" + sb + "', contextTokens " + contextTokens);
            System.out.println(sb);
        }
        
    }
}





def context_pruning(contexts, triggers):
    """
    Prunes contexts based on trigger words and prints the 
    results.
    """
    def pruned(context,trigger):
        try:
            words = context.split()
            i = words.index('-TITLE-')
            j = words.index(trigger)
            if i > j: # token on the left
                print ' '.join(words[j:i+2])
            else:     # token on the right
                print ' '.join(words[i-1 if i > 0 else 0:j+1])
            return True
        except:
            return False
        
    for context in contexts:
        for trigger in reversed(triggers):
            if pruned(context,trigger):
                break


class MyClass {
    public static void context_pruning(String[] contexts, String[] triggers) {
        
        // O(context.length * triggers.length)
        
        for (String s : contexts)
        {
            String[] toks = s.split(" +");
            
            // for each trigger
            boolean doneContext = false;
            for (int trig = triggers.length - 1; trig >= 0 && !doneContext; trig--)
            {
                boolean foundTrigger = false;
                boolean foundTitle = false;
                int titleIndex = 0;
                int trigIndex = 0;
                    
                // for each bit of the context
                for (int i = 0; i < toks.length && (!foundTrigger || !foundTitle); i++)
                {
                    if (toks[i].equals("-TITLE-")) 
                    {
                        titleIndex = i;
                        foundTitle = true;
                    }
                    else if (toks[i].equals(triggers[trig]))
                    {
                        trigIndex = i;
                        foundTrigger = true;
                    }
                }
                if (foundTrigger)
                {         
                    doneContext = true;
                    if (trigIndex < titleIndex)
                    {
                        // left side
                        System.out.println(makeString(toks, trigIndex, Math.min(titleIndex+2, toks.length)));
                    }
                    else
                    {
                        // right side
                        System.out.println(makeString(toks, Math.max(titleIndex-1, 0), trigIndex+1));   //need trigIndex + 1 so that trigIndex is inclusive                         
                    }
                }
            }
        }
    }
    
    public static String makeString(String[] a, int start, int end)
    {
        String str = "";
        for (int i = start; i < end; i++) str += a[i] + " ";
        return str.trim();
    }
    public static String makeString(String[] a)
    {
        return makeString(a, 0, a.length);
    }
}









Challenge: Extract book titles

In the previous challenge we have implemented context pruning and obtained high-precision contexts. These contexts have a high probability of identifying book titles.

Having a high-precision context

read -TITLE- on

and a tweet

“I’ve just read Design Patterns: Elements of Reusable Object-Oriented Software on my new Kindle!”

we can induce that Design Patterns: Elements of Reusable Object-Oriented Software is the name of a book because it is surrounded by the left side and the right side of a high-precision context.

Given a list of contexts sorted in decreasing order by their precision and a list of tweets

Your task is to

    * write a function that prints to the standard output (stdout) all book titles extracted from the tweets using the given contexts
    * please print one unique book title per line sorted in lexicographical order (alphabet order)
    * if a tweet matches multiple contexts please use only the one with the highest precision to extract the book title
    * If the same context matches a tweet multiple times, please pick the first match from left to right

Note that your function will receive the following arguments:

    * contexts
          o which is an array of strings giving a list of contexts
          o each context is a string of tokens containing the keyword "-TITLE-" (separated by spaces) which delimits the left side of the context and the right side of it
    * tweets
          o which is an array of strings representing tweets

Data constraints

    * the length of the contexts array will not exceed 1000
    * the length of a context string will not exceed 1000 characters
    * the length of the tweets array will not exceed 1000
    * the length of a tweet string will not exceed 140 characters
    * all string comparisons are case-sensitive

Efficiency constraints

    * your function is expected to print the requested result and return in less than 2 seconds

  



contexts: "read -TITLE- on Kindle", "read -TITLE- ", "-TITLE- is a good reading"

tweets: 
"I've just read Beautiful Code", 
"Yay! I've read The Old Man and the Sea on Kindle", 
"Thinking, Fast and Slow is a good reading"
 

import java.util.*;
import java.util.regex.*;

class MyClass {
   public static void extract_books(String[] contexts, String[] tweets) {
      String title = "-TITLE-";
      String[][] contextParts = new String[contexts.length][];
      for (int i=0; i<contexts.length; i++) {
         contexts[i] = contexts[i].trim();
         int ndx = contexts[i].indexOf(title);
         contextParts[i] = new String[] {contexts[i].substring(0, ndx).trim(), contexts[i].substring(ndx+title.length()).trim()};
      }
      List<String> result = new ArrayList<String>();
      for (String tweet : tweets) {
         for (int i=0; i<contexts.length; i++) {
            boolean matched = true;
            String book = new String(tweet);
            if (contextParts[i][0].length() > 0) {
               Pattern p = Pattern.compile("\\b" + contextParts[i][0] + "\\b");
               Matcher m = p.matcher(book);
               if (m.find()) {
                  book = book.substring(m.end());
               } else {                  
                  matched = false;
               }
            }
            if (contextParts[i][1].length() > 0) {
               Pattern p = Pattern.compile("\\b" + contextParts[i][1] + "\\b");
               Matcher m = p.matcher(book);
               int ndx = book.indexOf(contextParts[i][1]);
               if (m.find()) {
                  book = book.substring(0, m.start());
               } else {                     
                  matched = false;
               }
            }
            book = book.trim();
            if (matched && book.length() > 0) {
               result.add(book);
               break;
            }
         }
      }
      Collections.sort(result);
      for (String book : result) {
         System.out.println(book);
      }
   }
}
