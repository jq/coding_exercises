 Every week the number of unique visitors grow with 7% compared to the previous week.

Giving an integer number N representing the number of unique visitors at the end of this week and an integer number W

Your task is to

    write a function that prints to the standard output (stdout) the number of unique visitors we are going to have after W weeks
    please round the final result downwards to the nearest integer (e.g both 7.1 and 7.9 are rounded to 7)

Note that your function will receive the following arguments:

    n
        which is an integer representing the number N described above
    w
        which is an integer representing the number W described above

Data constraints

    the value for N will not exceed 10000
    the value for W will not exceed 50


class MyClass {
    public static void compute_prediction(Integer n, Integer w) {
        double sum = n;
        for (int i=0; i<w; i++) {
            sum = sum * 1.07;
        }
        
        int result = (int) Math.floor(sum);
        System.out.println(result);
        
    }
}

Your task is to

    write a function that prints to the standard output (stdout) the number of unique possible configurations (as, bs, cs) which can be used to serve exactly N visitors
    as represents the number of users from location a we choose to serve
    bs represents the number of users from location b we choose to serve
    cs represents the number of users from location c we choose to serve

Note that your function will receive the following arguments:

    a
        which is an integer representing the number of users from location a
    b
        which is an integer representing the number of users from location b
    c
        which is an integer representing the number of users from location c
    n
        which is an integer representing the number of users our servers can serve

Data constraints

    the values for a, b, c will be in the [0 .. 100] range
    n will always be smaller than the sum of a, b, and c


class MyClass {
    public static void count_configurations(Integer a, Integer b, Integer c, Integer n) {
        int matched = 0;
        for (int i=0; i<=a; i++) {
            for (int j=0; j<=b; j++) {
                for (int k=0; k<=c; k++) {

                    if (i+j+k == n) {
                        matched++;
                    }
                }
            }
        }      
        System.out.println(matched);
    }
}



 Given an array with all final grades for a course

Your task is to

    write a function that finds the highest grade and prints this grade to standard output (stdout)

Note that your function will receive the following arguments:

    grades
        which is the list of grades, represented as integer numbers

Data constraints

    the length of the array given as input will not exceed 1000 elements



import java.util.*;
class MyClass {
    public static void max_grade(Integer[] grades) {
        Arrays.sort(grades);
        System.out.println(grades[grades.length-1]);
        
    }
}


 Given an array with all final grades for a course and the minimum grade that a student needs to have in order to pass the course

Your task is to

    write a function that counts the number of students that passed and prints this number to standard output (stdout)

Note that your function will receive the following arguments:

    grades
        which is the list of grades, represented as integer numbers
    min_grade
        which is the minimum grade that a student can get, so that he passes the course

Data constraints

    the length of the array given as input will not exceed 1000 elements

Example
Input   Output

grades: 1, 2, 8, 4, 5, 8, 3
min_grade: 5
    
3

class MyClass {
    public static void count_successful_students(Integer[] grades, Integer min_grade) {
        int matched = 0;
        for (Integer grade : grades) {
            if (grade >= min_grade) {
                matched++;
            }
        }
        System.out.println(matched);
    }
}


 An easy way to understand how well the students performed at this years course is to compute the average of their final grades. If it is higher that the average for last year, that means the course was easier than last year.

Given an array with all final grades for a course

Your task is to

    write a function that computes the average of all the grades in the array and prints this number to standard output (stdout)
    the result must be rounded downwards to the nearest integer (e.g. both 7.1 and 7.9 are rounded to 7)

Note that your function will receive the following arguments:

    grades
        which is the list of grades, represented as integer numbers

Data constraints

    the length of the array given as input will not exceed 1000 elements


class MyClass {
    public static void compute_average_grade(Integer[] grades) {
        int sum = 0;
        for (Integer grade : grades) {
            sum += grade;
        }
        System.out.println(sum/grades.length);
    }
}



 Students are graded for their activity in each lab session.

It is expected that a students performance improves in time, which means that he should always receive a grade equal to or higher than the grade he received in the previous lab.

Given an array with the lab grades of a student

Your task is to

    write a function that checks whether the grades received by each student are in ascending order
    your function must print to standard output (stdout):
        1 if the grades are in ascending order (e.g. 1, 3, 3, 7)
        0 if the grades are not in ascending order (e.g. 1, 3, 7, 3)

Note that your function will receive the following arguments:

    grades
        which is an array containing the grades of the student

Data constraints

    the length of the array given as input will not exceed 1000 elements


class MyClass {
    public static void is_sorted(Integer[] grades) {
        for (int i=1; i<grades.length; i++) {
            if (grades[i-1] > grades[i]) {
                System.out.println(0);
                return;
            }
        }        
        System.out.println(1);
    }
}


 A student's performance in lab activities should always improve, but that is not always the case.

Since progress is one of the most important metrics for a student, lets write a program that computes the longest period of increasing performance for any given student.

For example, if his grades for all lab activities in a course are: 9, 7, 8, 2, 5, 6, 8, 7 then the longest period would be 4 consecutive labs (2, 5, 6, 8).

Given an array with the lab grades of a student

Your task is to

    write a function that computes and prints to standard output (stdout) the longest period of increasing performance for the student that has these grades

Note that your function will receive the following arguments:

    grades
        which is an array containing the grades of the student

Data constraints

    the length of the array given as input will not exceed 1000 elements


class MyClass {
    public static void longest_improvement(Integer[] grades) {
        int matched = 1;
        int max = -1;
        for (int i=1; i<grades.length; i++) {
            if (grades[i-1] <= grades[i]) {
                matched++;
                max = Math.max(matched, max);
            } else {
                matched = 1;
            }
        }
        System.out.println(max);
    }
}


 After an exam all the students are graded and sorted by their grades.

In some cases, students talk to the professor and conclude that one of the tougher problem statements in the exam was unclear and the teacher decides to remove its contribution towards the final grade.

Since its just one of many challenges, the sorted list of students wont change much - only a few students might change their order.

How do we implement an efficient algorithm that sorts a list of numbers that are almost sorted? Bubble sort is the perfect one for this specific case:

    bubblesort(A):
    repeat
        changed = false
        for i = 1 to length(A) - 1
            if A[i - 1] > A[i]
                swap A[i - 1], A[i]
                changed = true
    until not changed
  

Given an array of integer numbers

Your task is to

    implement the bubblesort algorithm to sort the array in ascending order and print the sorted elements to standard output (stdout), one per line

Note that your function will receive the following arguments:

    numbers
        which is the array of integer numbers that needs to be sorted

Data constraints

    the length of the array given as input will not exceed 1000 elements


import java.util.*;
class MyClass {
    public static void sort_students(Integer[] numbers) {
        Arrays.sort(numbers);
        for (Integer n : numbers) {
            System.out.println(n);
        }
        
    }
}



 A teacher wants to compare the performance of two students. To understand them better, hes looking at all the other courses they took, but its hard to spot the common courses just from a glance.

Given two arrays that contain the course IDs of two different students

Your task is to

    write a function that prints to standard output (stdout) all the course IDs that are contained in both arrays, sorted in ascending order, one per line

Note that your function will receive the following arguments:

    courses1
        which is the list of course IDs for the first student
    courses2
        which is the list of course ids for the second student

Data constraints

    the length of the array given as input will not exceed 1000 elements



import java.util.*;
class MyClass {
    private static boolean exists(Integer[] arr, int n) {
        for (Integer i : arr) {
            if (i.equals(n)) {
                return true;
            }
        }
        return false;
    }
    public static void get_common_courses(Integer[] courses1, Integer[] courses2) {
        List<Integer> list = new ArrayList<Integer>();
        for (int i=0; i<courses1.length; i++) {
            if (exists(courses2, courses1[i])) {
                list.add(courses1[i]);
            }
        }
        
        Collections.sort(list);
        for (Integer n : list) {
            System.out.println(n);
        }
    }
}

 common operation with text editors is selecting a block of text for further manipulation. Lets see how an editor extracts the characters between two given positions in a string.

Given a string S and two integer numbers p1, p2

Your task is to

    write a function that extracts all the characters between positions p1 and p2 in the given string and prints these characters to standard output (stdout)

Note that your function will receive the following arguments:

    s
        which is the string from which you must extract the specified characters
    p1
        which is the position of the left-most character that you must extract
    p2
        which is the position of the right-most character that you must extract

Data constraints

    the string will contain at most 1000 characters

class MyClass {
    public static void select_substring(String s, Integer p1, Integer p2) {
        StringBuilder sb = new StringBuilder();
        for (int i=p1-1; i<p2 && i<s.length(); i++) {
            sb.append(s.charAt(i));
        }
        System.out.println(sb);
    }
}



 Another common operation is deleting characters starting from the position of our cursor in the editor.

Given a string S, a position in this string P and a number N

Your task is to

    write a function that deletes N characters from the string S, starting from position P
    your function must print the newly formed string to standard output (stdout)

Note that your function will receive the following arguments:

    s
        which is the string from which we must delete the specified characters
    p
        which is the position in the string from which we must start deleting characters
    n
        which is the number of characters that must be deleted

Data constraints

    the string will contain at most 1000 characters

class MyClass {
    public static void remove_substring(String s, Integer p, Integer n) {
        StringBuilder sb = new StringBuilder();
        for (int i=0; i<s.length() && i< p-1; i++) {
            sb.append(s.charAt(i));
        }
        for (int i=p+n-1; i<s.length(); i++) {
            sb.append(s.charAt(i));
        }
        System.out.println(sb);        
    }
}




 When writing text we frequently use the copy and paste commands. Lets see how an editor implements the paste command.

Given two strings S1 and S2 and an integer number P

Your task is to

    write a function that inserts S2 into S1 starting with the position P in S1 and then prints the newly formed string S1 to standard output (stdout)

Note that your function will receive the following arguments:

    s1
        which is the string in which we must make the insertion
    s2
        which is the string that needs to be inserted
    p
        which is the position in s1 where s2 must be inserted

Data constraints

    the strings will contain at most 1000 characters



class MyClass {
    public static void copy_string(String s1, String s2, Integer p) {
        StringBuilder sb = new StringBuilder();
        for (int i=0; i<s1.length() && i< p; i++) {
            sb.append(s1.charAt(i));
        }
        sb.append(s2);
        for (int i=p; i<s1.length(); i++) {
            sb.append(s1.charAt(i));
        }
        System.out.println(sb);        
    }
}

 When writing an essay it is useful to know the total number of words that we have typed.

Let's define a word as any number of characters separated by spaces and commas. For example the string " one, ,two three,4," contains 4 words.

Given a string S

Your task is to

    write a function that counts the number of words in the given string and prints this number to standard output (stdout)

Note that your function will receive the following arguments:

    s
        which is the string for which you must count the number of words

Data constraints

    the string will contain at most 1000 characters



import java.util.*;
class MyClass {
    public static void count_words(String s) {
        StringTokenizer st = new StringTokenizer(s, " ,");
        int count = 0;
        while (st.hasMoreTokens()) {
            String next = st.nextToken();
            if (next.trim().length() > 0) {
                count++;
            }
        }
        System.out.println(count);
    }
}



 Some advanced code editors allow programmers to sort the words from a selected block of text. This is useful when we are polishing our code to make sure everything is readable and consistent.

Lets define a word as any number of characters separated by spaces and commas. For example the string " one, ,two three,4," contains 4 words.

Given a string S

Your task is to

    write a function that sorts all the words in the string alphabetically and prints them to standard output (stdout) in sorted order, one on each line

Note that your function will receive the following arguments:

    s
        which is the string from which you must extract and sort the words

Data constraints

    the string will contain at most 1000 characters

Example


import java.util.*;
class MyClass {
    public static void sort_words(String s) {
        StringTokenizer st = new StringTokenizer(s, " ,");
        List<String> words = new ArrayList<String>();
        while (st.hasMoreTokens()) {
            String next = st.nextToken().trim();
            if (next.length() > 0) {
                words.add(next);
            }
        }
        Collections.sort(words);
        for (String word : words) {
            System.out.println(word);
        }
    }
}



Given an integer number N

Your task is to

    write a function that prints to the standard output (stdout) the numbers from 1 to N (one per line) with the following restrictions
        for multiples of three print Fizz instead of the number
        for the multiples of five print Buzz instead of the number
        for numbers which are multiples of both three and five print FizzBuzz

Note that your function will receive the following arguments:

    n
        which is the integer number described above

Data constraints

    the maximum value of N will not exceed 1000

Efficiency constraints

    your function is expected to print the result in less than 2 seconds



class MyClass {
    public static void fizzbuzz(Integer n) {
        for (int i=1; i<=n; i++) {
            if (i % 3 == 0 && i % 5 == 0) {
                System.out.println("FizzBuzz");
            } else if (i % 3 == 0) {
                System.out.println("Fizz");
            } else if (i % 5 == 0) {
                System.out.println("Buzz");
            } else {
                System.out.println(i);
            }
        }
        
    }
}



As soon as a user inputs a query, the search engine must tokenize it - that means break it down into understandable tokens. A token is defined as a sequence of characters separated by white spaces and/or punctuation.

Given a string representing a user query and a set of punctuation characters

Your task is to

    write a function that prints to the standard output (stdout) all the tokens in the user query (one per line)

Note that your function will receive the following arguments:

    query
        which is a string giving the user query
    punctuation
        which is a string giving the punctuation characters that separate tokens

Data constraints

    the size of the query string will not exceed 1000 characters
    the size of the punctuation string will not exceed 10 characters

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example



import java.util.*;
class MyClass {
    public static void tokenize_query(String query, String punctuation) {
        StringTokenizer st = new StringTokenizer(query, punctuation + " ");
        List<String> words = new ArrayList<String>();
        while (st.hasMoreTokens()) {
            String next = st.nextToken().trim();
            if (next.length() > 0) {
                words.add(next);
            }
        }
        for (String word : words) {
            System.out.println(word);
        }        
    }
}



Stop words are tokens which are filtered out from queries because they add little value in finding relevant web pages.

Given a list of tokens that were obtained after the search engine tokenized the user query using your code from the previous task and a list of stopwords

Your task is to

    write a function that prints to the standard output (stdout) all the tokens in the user query that are not stop words (one per line)

Note that your function will receive the following arguments:

    query
        which is an array of strings giving the tokens in the user query
    stopwords
        which is an array of strings giving the stop words

Data constraints

    the length of the query array will not exceed 1000
    the length of the stopwords array will not exceed 1000
    all string comparisons are case-sensitive (i.e: Cool != cool)

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds



import java.util.*;
class MyClass {
    public static void remove_stopwords(String[] query, String[] stopwords) {
        List<String> result = new ArrayList<String>();    
        for (int i=0; i<query.length; i++) {
            boolean matched = false;
            for (int j=0; j<stopwords.length; j++) {
                if (query[i].equals(stopwords[j])) {
                    matched = true;
                    break;
                }
            }
            if (!matched) {
                result.add(query[i]);
            }
        }
        for (String word : result) {
            System.out.println(word);
        }
    }
}


Stemming removes word suffixes to reduce inflected (or sometimes derived) words to their base or root form.

E.g. friendly is an inflection of friend. By stemming (in this case stemming means removing the suffix ly), friendly is reduced to friend.

Given a list of tokens and a list of suffixes

Your task is to

    write a function that prints to the standard output (stdout) all the tokens having their suffix removed if found in the list of suffixes (please print one token per line)
    for each token if there is more than one suffix that can be removed please choose the one that is the longest

Note that your function will receive the following arguments:

    tokens
        which is an array of strings giving the tokens described above
    suffixes
        which is an array of strings giving the suffixes described above

Data constraints

    the length of the tokens array will not exceed 1000
    the length of the suffixes array will not exceed 100
    all string comparisons are case-sensitive (i.e: Cool != cool)

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example



import java.util.*;
class MyClass {
    private static final Comparator<String> CMP = new Comparator<String>(){
        @Override
        public int compare(String o1, String o2) {  
            if (o1.length() > o2.length()) {
                return 1;
            } else if (o1.length() < o2.length()) {
                return -1;
            }
            return o1.compareTo(o2);
        }
    };
    public static void token_stemming(String[] tokens, String[] suffixes) {
        List<String> result = new ArrayList<String>();
        Arrays.sort(suffixes, CMP);
        for (int i=0; i<tokens.length; i++) {
            String word = tokens[i];
            for (int j=suffixes.length-1; j>=0; j--) {
                if (tokens[i].endsWith(suffixes[j])) {
                    word = word.substring(0, word.length()-suffixes[j].length());
                    break;
                }
            }
            result.add(word);
        }
        for (String word : result) {
            System.out.println(word);
        }        
    }
}



It's time to retrieve the web pages that match a user query.

Given a query as a list of tokens and a list of strings representing the content of each web page

Your task is to

    write a function that prints to the standard output (stdout) the number of web pages that contain all the given tokens in the same order.

Note that your function will receive the following arguments:

    query
        which is an array of strings giving the tokens in the user query
    pages
        which is an array of strings giving the content of each web page

Data constraints

    the length of the query array will not exceed 10
    the length of the pages array will not exceed 1000
    the length of any web page content will not exceed 1000
    all string comparisons are case-sensitive (i.e: Cool != cool)

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example


class MyClass {
    public static void search_query(String[] query, String[] pages) {
        int count = 0;
        for (int i=0; i<pages.length; i++) {
            int matched = 0;
            int index = 0;
            for (int j=0; j<query.length; j++) {
                int mndx = pages[i].indexOf(query[j], index);
                if (mndx != -1) {
                    index = mndx + query[j].length();
                    matched++;
                }
            }
            if (matched == query.length) {
                count++;
            }
        }
        System.out.println(count);
        
    }
}



Challenge: Context extraction

Considering the name of a book and the tweet mentioning it we define the context of the book as a sequence of tokens immediately preceding and immediately following the book name in the tweet.

    A token is defined as a sequence of characters that occur between white spaces.
    The size of the context is W tokens on each side (preceding and following the book name)

For example, having the book title "Beautiful Code", W=2 and the following tweet

"I read Beautiful Code and it was simply amazing"

the context is "I read -TITLE- and it"

Given a list of book titles, a list of tweets and W

Your task is to

    write a function that prints to the standard output (stdout) for each book all the contexts that can be extracted from the list of tweets (one per line in the same order with the tweets that generated those contexts)
    each context must be printed as a string formed by concatenating the tokens preceding the book title, the keyword "-TITLE-" (one white space on both sides) and the tokens following the book title
    please take into consideration the following constraints:
        A book title matches a tweet if all its tokens match a sequence of consecutive tokens in the tweet (e.g. "Beautiful Code" does not match "Beautiful A Code")
        If the number of available tokens preceding or following a book title is lower than W extract only those available.
        If a context is empty on both the left and the right side it must be ignored, otherwise it is considered valid

Note that your function will receive the following arguments:

    books
        which is an array of strings representing the book titles
    tweets
        which is an array of strings representing the tweets
    w
        which is an integer number as described above

Data constraints

    the length of the books array will not exceed 50
    the length of the tweets array will not exceed 10000

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example


class MyClass {
    public static void extract_contexts(String[] books, String[] tweets, Integer w) {
        for (int j=0; j<books.length; j++) {
            for (int i=0; i<tweets.length; i++) {
                int ndx = 0;
                StringBuilder sb = new StringBuilder();

                while ((ndx=tweets[i].indexOf(books[j], ndx)) != -1) {
                    String[] prefix = tweets[i].substring(0, ndx).split(" ");
                    for (int k=prefix.length-1, l=0; k >= 0 && l<w; k--, l++) {
                        String word = prefix[k].trim();
                        if (word.length() == 0) {
                            l--;
                            continue;
                        }
                        if (sb.length() > 0) {
                            sb.insert(0, " ");
                        }
                        
                        sb.insert(0, word);
                    }
                    sb.append(" -TITLE- ");
                    ndx += books[j].length();
                    String[] suffix = tweets[i].substring(ndx).split(" ");

                    for (int k=0, l=0; k < suffix.length && l<w; k++, l++) {
                        String word = suffix[k].trim();
                        if (word.length() == 0) {
                            l--;
                            continue;
                        }
                        sb.append(word);
                        if (k<suffix.length-1 && l<w-1) {
                            sb.append(" ");
                        }
                    }
                }
                final String result = sb.toString().trim();
                if (result.length() > 0) {
                    System.out.println(result);
                }
            }
        }
        
    }
}


Challenge: Trigger words

Lets consider a context that was extracted during the previous challenge:

Did you read -TITLE- on Kindle yesterday?

In this example, "read" and "Kindle" are trigger words. These types of words signal that theres a high likelihood of finding a book title in their vicinity.

A trigger word is a token that has two properties:

    it is frequent in the list of extracted contexts
    it is specific to the field of books

In order to identify trigger words we are going to assign a weight to each token. Lets call this weight: IDF ("inverse document frequency").

IDF(token) = log(N / num_contexts(token))

    N represents the total number of contexts we are working with
    num_contexts(token) represents the number of contexts that contain the given token
    log() represents the natural logarithm (base E) of a number.

Given a list of contexts and an integer number M

Your task is to

    write a function that prints to the standard output (stdout) the first M tokens having the highest IDF value (one per line)
    if there are more tokens having the same IDF value they must be sorted in lexicographical order

Note that your function will receive the following arguments:

    contexts
        which is an array of strings giving a list of contexts
        each context is a string of tokens containing the keyword "-TITLE-" (separated by spaces) which delimits the left side of the context and the right side of it
    m
        which is an integer number giving the number mentioned above

Data constraints

    the length of the contexts array will not exceed 1000
    the length of a context string will not exceed 1000 characters

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

contexts: "to read -TITLE- while in", "to buy -TITLE- while in school", "buy -TITLE-"

m: 2
    

read
school

Explanation

    In this example we are working with 3 contexts, so N = 3
    IDF("read") = log(3/1) = 1.09
    IDF("buy") = log(3/2) = 0.40



import java.util.*;
class MyClass {
    static int N;
    static class Info implements Comparable<Info> {        
        String token;
        int num_context;
        public Info(String token) {
            this.token = token;
            num_context = 1;
        }
        double idf() {
            return Math.log(N / num_context);            
        }
        @Override
        public int compareTo(Info other) {
            if (other.idf() < idf()) {
                return -1;
            } else if (other.idf() > idf()) {
                return +1;
            } else {
                return token.compareTo(other.token);
            }
        }
        @Override public String toString() {
            return token + ", N " + N + ", num " + num_context + ", idf " + idf() + "\n";
        }
    }
    public static void extract_trigger_words(String[] contexts, Integer m) {
        N = contexts.length;
        Map<String, Info> idfMap = new TreeMap<String, Info>();
        for (String c : contexts) {
            String[] arr = c.split(" ");
            Arrays.sort(arr);
            for (int i=0; i<arr.length; i++) {
                if (!arr[i].equals("-TITLE-")) {
                    Info info = idfMap.get(arr[i]);
                    if (info == null) {
                        idfMap.put(arr[i], new Info(arr[i]));
                    } else {
                        if (i > 1 && arr[i-1].equals(arr[i])) {
                            //skip
                        } else {
                            info.num_context++;
                        }
                    }
                }
            }
        }
        List<Info> idfList = new ArrayList<Info>(idfMap.values());
        Collections.sort(idfList);
        for (int i=0; i<m && i<idfList.size(); i++) {
            System.out.println(idfList.get(i).token);
        }
    }
}

Context pruning

Youve obtained the set of trigger words, congrats!

Its time to remove the tokens that are not useful in predicting a book title in their vicinity from each context. This operation is called pruning.

Pruning each context is done in the following fashion:

    select the token which is a trigger word and has the highest IDF (inverse document frequency)
    if none of the tokens is a trigger word then ignore the context
    if the token is on the left side of the context
        we keep the token and all tokens on its right
        for the right side of the context we keep only the first token (if exists)
    if the token is on the right side of the context
        we keep the token and all tokens on its left
        for the left side of the context we keep only the last token (if exists)

Considering the list of trigger words [Kindle, read] sorted in ascending order by their IDF, pruning the context: Did you read -TITLE- on Kindle yesterday? will produce the following result:

    read -TITLE- on

Given a list of contexts and a list of trigger words sorted in ascending order by IDF

Your task is to

    write a function that prunes the contexts and prints the results to the standard output (stdout)

Note that your function will receive the following arguments:

    contexts
        which is an array of strings giving a list of contexts
        each context is a string of tokens containing the keyword "-TITLE-" (separated by spaces) which delimits the left side of the context and the right side of it
    triggers
        which is an array of strings representing trigger words sorted in ascending order by IDF

Data constraints

    the length of the contexts array will not exceed 1000
    the length of a context string will not exceed 1000 characters
    the length of the triggers array will not exceed 1000
    the length of a trigger word will not exceed 100 characters

Efficiency constraints

    your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

contexts: "to read -TITLE- while in", "to buy -TITLE- while in school", "buy -TITLE-"

triggers: "read", "school"
    

read -TITLE- while
buy -TITLE- while in school




import java.util.*;
class MyClass {
    
    private static void append(List<String> contextTokens, String matchingTrigger, String leftOfTitle,String rightOfTitle, StringBuilder sb) {
        boolean printedTitle = false;
        for (int i=0; i<contextTokens.size(); i++) {
            if (contextTokens.get(i).equals(matchingTrigger)) {
                continue;
            }
            if (sb.length() > 0) {
                sb.append(" ");
            }
            if (!printedTitle && rightOfTitle != null && contextTokens.get(i).equals(rightOfTitle)) {
                sb.append("-TITLE- ");
                printedTitle = true;
            }
            sb.append(contextTokens.get(i));
            if (!printedTitle && leftOfTitle != null && contextTokens.get(i).equals(leftOfTitle)) {
                sb.append(" -TITLE-");
                printedTitle = true;
            }
        }
        if (!printedTitle) {
            sb.append(" -TITLE-");
        }
    }
    private static boolean idfHigher(String matchingTrigger, String token, String[] triggers) {
        int matchingIdfIndex = -1;
        int tokenIdfIndex = -1;
        for (int i=0; i<triggers.length; i++) {
            if (triggers[i].equals(matchingTrigger)) {
                matchingIdfIndex = i;
            }
            if (triggers[i].equals(token)) {
                tokenIdfIndex = i;
            }
        }
        if (matchingIdfIndex == -1 || tokenIdfIndex == -1) {
            return false;
        }
        return matchingIdfIndex < tokenIdfIndex; // triggers are in asc IDF
    }
    public static void context_pruning(String[] contexts, String[] triggers) {
        for (String context : contexts) {
            String matchingTrigger = null;
            boolean matchedTokenOnLeftSide = true;
            String leftOfTitle = null;
            String rightOfTitle = null;
            List<String> contextTokens = new ArrayList<String>();
            List<String> tokensSinceMatchingToken = new ArrayList<String>();
            boolean foundTitle = false;
            for (String token : context.split(" ")) {
                if (token.equals("-TITLE-")) {
                    foundTitle = true;
                    if (matchingTrigger == null) {
                        contextTokens.clear();
                    }
                    continue;
                }
                //
                if (!foundTitle) {
                    leftOfTitle = token;
                } else if (rightOfTitle == null) {
                    rightOfTitle = token;
                }
                //
                for (String trigger : triggers) {
                    if (token.equals(trigger) && (matchingTrigger == null || idfHigher(matchingTrigger, token, triggers))) {
                        matchingTrigger = token;
                        if (foundTitle) {
                            matchedTokenOnLeftSide = false;
                        } else {
                            contextTokens.clear();
                            matchedTokenOnLeftSide = true;
                        }
                        for (String t : tokensSinceMatchingToken) {
                            if (contextTokens.indexOf(t) == -1) {
                                contextTokens.add(t);
                            }
                        }
                        tokensSinceMatchingToken.clear();
                    } else if ((matchingTrigger == null || !foundTitle) && !token.equals(matchingTrigger)) {
                        if (contextTokens.indexOf(token) == -1) {
                            contextTokens.add(token);
                        }
                    } else if (matchingTrigger != null && !token.equals(matchingTrigger) && tokensSinceMatchingToken.indexOf(token) == -1) {
                        tokensSinceMatchingToken.add(token);
                    }
                }
            }
            if (matchingTrigger == null) {
                // ignore 
                continue;
            }
            StringBuilder sb = new StringBuilder();
            if (matchedTokenOnLeftSide) {
                sb.append(matchingTrigger);
                append(contextTokens, matchingTrigger, leftOfTitle, rightOfTitle, sb);

                if (rightOfTitle != null && contextTokens.indexOf(rightOfTitle) == -1) {
                    sb.append(" " + rightOfTitle);
                }
            } else {
                if (leftOfTitle != null && contextTokens.indexOf(leftOfTitle) == -1) {
                    sb.append(leftOfTitle);
                }
                append(contextTokens, matchingTrigger, leftOfTitle, rightOfTitle, sb);

                sb.append(" " + matchingTrigger);


            }
            //System.out.println("matchingTrigger " + matchingTrigger + ", left " + matchedTokenOnLeftSide + ", Context '" + context + "': '" + sb + "', contextTokens " + contextTokens);
            System.out.println(sb);
        }
        
    }
}





def context_pruning(contexts, triggers):
    """
    Prunes contexts based on trigger words and prints the 
    results.
    """
    def pruned(context,trigger):
        try:
            words = context.split()
            i = words.index('-TITLE-')
            j = words.index(trigger)
            if i > j: # token on the left
                print ' '.join(words[j:i+2])
            else:     # token on the right
                print ' '.join(words[i-1 if i > 0 else 0:j+1])
            return True
        except:
            return False
        
    for context in contexts:
        for trigger in reversed(triggers):
            if pruned(context,trigger):
                break


class MyClass {
    public static void context_pruning(String[] contexts, String[] triggers) {
        
        // O(context.length * triggers.length)
        
        for (String s : contexts)
        {
            String[] toks = s.split(" +");
            
            // for each trigger
            boolean doneContext = false;
            for (int trig = triggers.length - 1; trig >= 0 && !doneContext; trig--)
            {
                boolean foundTrigger = false;
                boolean foundTitle = false;
                int titleIndex = 0;
                int trigIndex = 0;
                    
                // for each bit of the context
                for (int i = 0; i < toks.length && (!foundTrigger || !foundTitle); i++)
                {
                    if (toks[i].equals("-TITLE-")) 
                    {
                        titleIndex = i;
                        foundTitle = true;
                    }
                    else if (toks[i].equals(triggers[trig]))
                    {
                        trigIndex = i;
                        foundTrigger = true;
                    }
                }
                if (foundTrigger)
                {         
                    doneContext = true;
                    if (trigIndex < titleIndex)
                    {
                        // left side
                        System.out.println(makeString(toks, trigIndex, Math.min(titleIndex+2, toks.length)));
                    }
                    else
                    {
                        // right side
                        System.out.println(makeString(toks, Math.max(titleIndex-1, 0), trigIndex+1));   //need trigIndex + 1 so that trigIndex is inclusive                         
                    }
                }
            }
        }
    }
    
    public static String makeString(String[] a, int start, int end)
    {
        String str = "";
        for (int i = start; i < end; i++) str += a[i] + " ";
        return str.trim();
    }
    public static String makeString(String[] a)
    {
        return makeString(a, 0, a.length);
    }
}









Challenge: Extract book titles

In the previous challenge we have implemented context pruning and obtained high-precision contexts. These contexts have a high probability of identifying book titles.

Having a high-precision context

read -TITLE- on

and a tweet

“I’ve just read Design Patterns: Elements of Reusable Object-Oriented Software on my new Kindle!”

we can induce that Design Patterns: Elements of Reusable Object-Oriented Software is the name of a book because it is surrounded by the left side and the right side of a high-precision context.

Given a list of contexts sorted in decreasing order by their precision and a list of tweets

Your task is to

    * write a function that prints to the standard output (stdout) all book titles extracted from the tweets using the given contexts
    * please print one unique book title per line sorted in lexicographical order (alphabet order)
    * if a tweet matches multiple contexts please use only the one with the highest precision to extract the book title
    * If the same context matches a tweet multiple times, please pick the first match from left to right

Note that your function will receive the following arguments:

    * contexts
          o which is an array of strings giving a list of contexts
          o each context is a string of tokens containing the keyword "-TITLE-" (separated by spaces) which delimits the left side of the context and the right side of it
    * tweets
          o which is an array of strings representing tweets

Data constraints

    * the length of the contexts array will not exceed 1000
    * the length of a context string will not exceed 1000 characters
    * the length of the tweets array will not exceed 1000
    * the length of a tweet string will not exceed 140 characters
    * all string comparisons are case-sensitive

Efficiency constraints

    * your function is expected to print the requested result and return in less than 2 seconds

  



contexts: "read -TITLE- on Kindle", "read -TITLE- ", "-TITLE- is a good reading"

tweets: 
"I've just read Beautiful Code", 
"Yay! I've read The Old Man and the Sea on Kindle", 
"Thinking, Fast and Slow is a good reading"
 

import java.util.*;
import java.util.regex.*;

class MyClass {
   public static void extract_books(String[] contexts, String[] tweets) {
      Pattern titleP = Pattern.compile("\\s?.TITLE.\\s?");
      String[][] contextParts = new String[contexts.length][];
      for (int i=0; i<contexts.length; i++) {
         Matcher m = titleP.matcher(contexts[i]);
         if (m.find()) {
            contextParts[i] = new String[] {contexts[i].substring(0, m.start()), contexts[i].substring(m.end())};
         }
      }
      List<String> result = new ArrayList<String>();
      for (String tweet : tweets) {
         for (int i=0; i<contexts.length; i++) {
            boolean matched = true;
            String book = new String(tweet);
            if (contextParts[i][0].length() > 0) {
               Pattern p = Pattern.compile("\\b" + contextParts[i][0] + "\\b");
               Matcher m = p.matcher(book);
               if (m.find()) {
                  book = book.substring(m.end());
               } else {                  
                  matched = false;
               }
            }
            if (contextParts[i][1].length() > 0) {
               Pattern p = Pattern.compile("\\b" + contextParts[i][1] + "\\b");
               Matcher m = p.matcher(book);
               if (m.find()) {
                  String nbook = book;
                  book = book.substring(0, m.start());
               } else {
                  matched = false;
               }
            }
            book = book.trim();
            if (matched && book.length() > 0) {
               if (result.indexOf(book) == -1) {
                  result.add(book);
               }
               break;
            }
         }
      }
      Collections.sort(result);
      for (String book : result) {
         System.out.println(book);
      }
   }
   public static void main(String[] args) {
      //String[] contexts = new String[] { "planks -TITLE- "," -TITLE- to","It's -TITLE- easy","chicken leg -TITLE- is","Rice -TITLE- is","fine -TITLE- punch","beside -TITLE- the parked","and -TITLE- garbage","us -TITLE- ","sell -TITLE- ","The -TITLE- boy was there when","A rod -TITLE- is"," -TITLE- of","and follow through -TITLE- ","woman -TITLE- get","of -TITLE- tea helps","lack -TITLE- flame and heat","broke the man's fall -TITLE- ","breeze -TITLE- came across from the","The girl -TITLE- at","small -TITLE- pup gnawed a","twisted and turned -TITLE- on"," -TITLE- and","swan dive was -TITLE- far"," -TITLE- the","the -TITLE- tank","useless -TITLE- trash"," -TITLE- reared","and hailed -TITLE- the","loud -TITLE- for pleasure","to your left -TITLE- shoulder","winding -TITLE- path to reach the","size of -TITLE- the","grease -TITLE- off his","coat before you -TITLE- go","was -TITLE- badly","cat -TITLE- gave birth to","The young -TITLE- girl","was -TITLE- cooked before","living -TITLE- ","ruled -TITLE- the","reef -TITLE- ","home -TITLE- the third week","The -TITLE- wide road shimmered in","lay -TITLE- in the","stone -TITLE- over","at -TITLE- once","and -TITLE- plunge in","drug -TITLE- store","keeps -TITLE- chicks inside"};
      //String[] tweets  = new String[]  {"The birch canoe slid on the smooth planks","The birch canoe slid on the smooth planks After Many a Summer Dies the Swan","Glue the sheet to the dark blue background","Glue the sheet Ah, Wilderness! to the dark blue background","It's easy to tell the depth of a well","It's All Passion Spent easy to tell the depth of a well","These days a chicken leg is a rare dish","These days a chicken leg All the King's Men is a rare dish","Rice is often served in round bowls","Rice Alone on a Wide, Wide Sea is often served in round bowls","The juice of lemons makes fine punch","The juice of lemons makes fine An Acceptable Time punch","The box was thrown beside the parked truck","The box was thrown beside Antic Hay the parked truck","The hogs were fed chopped corn and garbage","The hogs were fed chopped corn and An Evil Cradling garbage","Four hours of steady work faced us","Four hours of steady work faced us Arms and the Man","A large size in stockings is hard to sell","A large size in stockings is hard to sell As I Lay Dying","The boy was there when the sun rose","The A Time to Kill boy was there when the sun rose","A rod is used to catch pink salmon","A rod Behold the Man is used to catch pink salmon","The source of the huge river is the clear spring","The source Beneath the Bleeding of the huge river is the clear spring","Kick the ball straight and follow through","Kick the ball straight and follow through Beyond the Mexique Bay","Help the woman get back to her feet","Help the woman Blithe Spirit get back to her feet","A pot of tea helps to pass the evening","A pot of Blood's a Rover tea helps to pass the evening","Smoky fires lack flame and heat","Smoky fires lack Bonjour Tristesse flame and heat","The soft cushion broke the man's fall","The soft cushion broke the man's fall Brandy of the Damned","The salt breeze came across from the sea","The salt breeze Brave New World came across from the sea","The girl at the booth sold fifty bonds","The girl Bury My Heart at Wounded Knee at the booth sold fifty bonds","The small pup gnawed a hole in the sock","The small Butter In a Lordly Dish pup gnawed a hole in the sock","The fish twisted and turned on the bent hook","The fish twisted and turned Cabbages and Kings on the bent hook","Press the pants and sew a button on the vest","Press the pants Clouds of Witness and sew a button on the vest","The swan dive was far short of perfect","The swan dive was A Confederacy of Dunces far short of perfect","The beauty of the view stunned the young boy","The beauty of Consider Phlebas the view stunned the young boy","Two blue fish swam in the tank","Two blue fish swam in the Consider the Lilies tank","Her purse was full of useless trash","Her purse was full of useless Cover Her Face trash","The colt reared and threw the tall rider","The colt The Cricket on the Hearth reared and threw the tall rider","It snowed, rained, and hailed the same morning","It snowed, rained, and hailed The Curious Incident of the Dog in the Night-Time the same morning","Read verse out loud for pleasure","Read verse out loud The Daffodil Sky for pleasure","Hoist the load to your left shoulder","Hoist the load to your left Dance Dance Dance shoulder","Take the winding path to reach the lake","Take the winding A Darkling Plain path to reach the lake","Note closely the size of the gas tank","Note closely the size of Death Be Not Proud the gas tank","Wipe the grease off his dirty face","Wipe the grease The Doors of Perception off his dirty face","Mend the coat before you go out","Mend the coat before you Down to a Sunless Sea go out","The wrist was badly strained and hung limp","The wrist was Dulce et Decorum Est badly strained and hung limp","The stray cat gave birth to kittens","The stray cat Dying of the Light gave birth to kittens","The young girl gave no clear response","The young East of Eden girl gave no clear response","The meal was cooked before the bell rang","The meal was Ego Dominus Tuus cooked before the bell rang","What joy there is in living","What joy there is in living Endless Night","A king ruled the state in the early days","A king ruled Everything is Illuminated the state in the early days","The ship was torn apart on the sharp reef","The ship was torn apart on the sharp reef Eyeless in Gaza","Sickness kept him home the third week","Sickness kept him home Fair Stood the Wind for France the third week","The wide road shimmered in the hot sun","The Fame Is the Spur wide road shimmered in the hot sun","The lazy cow lay in the cool grass","The lazy cow lay A Fanatic Heart in the cool grass","Lift the square stone over the fence","Lift the square stone The Far-Distant Oxus over the fence","The rope will bind the seven books at once","The rope will bind the seven books at A Farewell to Arms once","Hop over the fence and plunge in","Hop over the fence and Far From the Madding Crowd plunge in","The friendly gang left the drug store","The friendly gang left the drug Fear and Trembling store","Mesh wire keeps chicks inside","Mesh wire keeps For a Breath I Tarry chicks inside","The frosty air passed through the coat","The crooked maze failed to fool the mouse","Adding fast leads to wrong sums","The show was a flop from the very start","A saw is a tool used for making boards","The wagon moved on well oiled wheels","March the soldiers past the next hill","A cup of sugar makes sweet fudge","Place a rosebush near the porch steps","Both lost their lives in the raging storm","We talked of the side show in the circus","Use a pencil to write the first draft","He ran half way to the hardware store","The clock struck to mark the third period","A small creek cut across the field","Cars and busses stalled in snow drifts","The set of china hit the floor with a crash","This is a grand season for hikes on the road","The dune rose from the edge of the water","Those words were the cue for the actor to leave","A yacht slid around the point into the bay","The two met while playing on the sand","The ink stain dried on the finished page","The walled town was seized without a fight","The lease ran out in sixteen weeks","A tame squirrel makes a nice pet","The horn of the car woke the sleeping cop","The heart beat strongly and with firm strokes","The pearl was worn in a thin silver ring","The fruit peel was cut in thick slices","The Navy attacked the big task force","See the cat glaring at the scared mouse","There are more than two factors here","The hat brim was wide and too droopy","The lawyer tried to lose his case","The grass curled around the fence post","Cut the pie into large parts","Men strive but seldom get rich","Always close the barn door tight","He lay prone and hardly moved a limb","The slush lay deep along the street","A wisp of cloud hung in the blue air","A pound of sugar costs more than eggs","The fin was sharp and cut the clear water","The play seems dull and quite stupid","Bail the boat to stop it from sinking","The term ended in late june that year","A Tusk is used to make costly gifts","Ten pins were set in order","The bill was paid every third week"};
      String[] contexts = new String[] {"on the smooth -TITLE- planks","sheet -TITLE- to the dark","It's -TITLE- easy to tell the","leg -TITLE- is a"," -TITLE- is","of -TITLE- lemons"," -TITLE- thrown","chopped corn -TITLE- and","work faced us -TITLE- ","A -TITLE- large size"};
      String[] tweets  = new String[]  {"The birch canoe slid on the smooth planks","The birch canoe slid on the smooth After Many a Summer Dies the Swan planks","Glue the sheet to the dark blue background","Glue the sheet Ah, Wilderness! to the dark blue background","It's easy to tell the depth of a well","It's All Passion Spent easy to tell the depth of a well","These days a chicken leg is a rare dish","These days a chicken leg All the King's Men is a rare dish","Rice is often served in round bowls","Rice Alone on a Wide, Wide Sea is often served in round bowls","The juice of lemons makes fine punch","The juice of An Acceptable Time lemons makes fine punch","The box was thrown beside the parked truck","The box was Antic Hay thrown beside the parked truck","The hogs were fed chopped corn and garbage","The hogs were fed chopped corn An Evil Cradling and garbage","Four hours of steady work faced us","Four hours of steady work faced us Arms and the Man","A large size in stockings is hard to sell","A As I Lay Dying large size in stockings is hard to sell","The boy was there when the sun rose","A rod is used to catch pink salmon","The source of the huge river is the clear spring","Kick the ball straight and follow through","Help the woman get back to her feet","A pot of tea helps to pass the evening","Smoky fires lack flame and heat","The soft cushion broke the man's fall","The salt breeze came across from the sea","The girl at the booth sold fifty bonds","The small pup gnawed a hole in the sock","The fish twisted and turned on the bent hook","Press the pants and sew a button on the vest","The swan dive was far short of perfect","The beauty of the view stunned the young boy","Two blue fish swam in the tank","Her purse was full of useless trash","The colt reared and threw the tall rider","It snowed, rained, and hailed the same morning","Read verse out loud for pleasure","Hoist the load to your left shoulder","Take the winding path to reach the lake","Note closely the size of the gas tank","Wipe the grease off his dirty face","Mend the coat before you go out","The wrist was badly strained and hung limp","The stray cat gave birth to kittens","The young girl gave no clear response","The meal was cooked before the bell rang","What joy there is in living","A king ruled the state in the early days","The ship was torn apart on the sharp reef","Sickness kept him home the third week","The wide road shimmered in the hot sun","The lazy cow lay in the cool grass","Lift the square stone over the fence","The rope will bind the seven books at once","Hop over the fence and plunge in","The friendly gang left the drug store","Mesh wire keeps chicks inside","The frosty air passed through the coat","The crooked maze failed to fool the mouse","Adding fast leads to wrong sums","The show was a flop from the very start","A saw is a tool used for making boards","The wagon moved on well oiled wheels","March the soldiers past the next hill","A cup of sugar makes sweet fudge","Place a rosebush near the porch steps","Both lost their lives in the raging storm","We talked of the side show in the circus","Use a pencil to write the first draft","He ran half way to the hardware store","The clock struck to mark the third period","A small creek cut across the field","Cars and busses stalled in snow drifts","The set of china hit the floor with a crash","This is a grand season for hikes on the road","The dune rose from the edge of the water","Those words were the cue for the actor to leave","A yacht slid around the point into the bay","The two met while playing on the sand","The ink stain dried on the finished page","The walled town was seized without a fight","The lease ran out in sixteen weeks","A tame squirrel makes a nice pet","The horn of the car woke the sleeping cop","The heart beat strongly and with firm strokes","The pearl was worn in a thin silver ring","The fruit peel was cut in thick slices","The Navy attacked the big task force","See the cat glaring at the scared mouse","There are more than two factors here","The hat brim was wide and too droopy","The lawyer tried to lose his case","The grass curled around the fence post","Cut the pie into large parts","Men strive but seldom get rich","Always close the barn door tight","He lay prone and hardly moved a limb","The slush lay deep along the street","A wisp of cloud hung in the blue air","A pound of sugar costs more than eggs","The fin was sharp and cut the clear water","The play seems dull and quite stupid","Bail the boat to stop it from sinking","The term ended in late june that year","A Tusk is used to make costly gifts","Ten pins were set in order","The bill was paid every third week"};
      extract_books(contexts, tweets);
   } 
}























Challenge: Fast power

Searching for a string in a large data store by simply comparing characters would take ages or a huge amount of computing power. We need a way to do it fast!

The first step to building a fast search algorithm is to encode the data in a format that makes search efficient.

A critical operation in the encoding process which we’ll get familiar with a bit later is the exponentiation of integer numbers.

Given a list of pairs of integers (a,b)

Your task is to

    * write a function that prints to the standard output (stdout) for each pair the result of (ab) modulo 4211 (one per line)

Note that your function will receive the following arguments:

    * a
          o which is an array of integers giving the first element (a) of each pair
    * b
          o which is an array of integers giving the second element (b) of each pair

The ith pair is defined by a[i] and b[i].

Data constraints

    * the length of a, b arrays will not exceed 10000
    * elements of a, b arrays are integer numbers in the [0, 50000]

Efficiency constraints

    * your function is expected to print the requested result and return in less than 2 seconds
    * make sure you don't use any methods that do significant work for you (e.g. pow() in Python)

Example
Input   Output

a: 41619, 169, 29227, 13232

b: 6, 5, 7, 8
   

3226
3461
2507
2597 


http://homepages.math.uic.edu/~leon/cs-mcs401-s08/handouts/fastexp.pdf 



import java.io.*;

class MyClass {  
    private static long exp(int a, int b, int m) { 
       long x= a;
       long y = b % 2 == 1 ? a : 1;
       long n = (long) Math.floor(b / 2);
       while (n > 0) { 
          x = (x * x) % m;
          if (n % 2 == 1) { 
             y = y == 1 ? x : (y * x) % m;
          }
         n = (long) Math.floor(n / 2);
       }
       return y;
   }


   public static void fast_power(Integer[] a, Integer[] b) {
      for (int i=0; i<a.length; i++) {
         System.out.println(exp(a[i], b[i], 4211));
      }
   }  
   public static void main(String[] args) throws Exception { 
      BufferedReader in = new BufferedReader(new FileReader(args[0])); 
      String[] tokens1 = in.readLine().split(",");
      String[] tokens2 = in.readLine().split(",");
      Integer[] a = new Integer[tokens1.length];
      Integer[] b = new Integer[tokens2.length]; 
      for (int i=0; i<tokens1.length; i++) { 
         a[i] = Integer.valueOf(tokens1[i]);
         b[i] = Integer.valueOf(tokens2[i]);
      }
      //a = new Integer[] {41619,169,29227,13232};
      //b = new Integer[] {6,5,7,8};
      //a = new Integer[] {46634};
      //b = new Integer[] {3}; // 4006
      long started = System.currentTimeMillis();
      //_fast_power(a, b);
      fast_power(a, b);
      System.out.println("finished processing " + tokens1.length + " numbers in " + (System.currentTimeMillis()-started));
   }
}



#include <iostream>
#include <vector>

using namespace std;

unsigned mod_pow(unsigned num, unsigned pow, unsigned mod)
{
    unsigned test;
    for(test = 1; pow; pow >>= 1)
    {
        if (pow & 1)
            test = (test * num) % mod;
        num = (num * num) % mod;
    }

    return test;
}

void fast_power(const vector<int> &a, const vector<int> &b) {
        int size = a.size();
    
        for (int i = 0; i < size; i++) {
            int total = mod_pow(a[i], b[i], 4211);
/*            
            int power = b[i];
            
            for (int j = 0; j < power; j++) {
                total = (total * a[i]) % 4211;
            }
*/

            cout << total << "\n";
        }
    
}





Peter Norvig solved Fast power in Python 
def fast_power(a, b):
    for (ai, bi) in zip(a, b):
        print powmod(ai, bi, 4211)
        
def powmod(a, b, m):
    "Return a**b mod m"
    if b == 0: return 1
    if b == 1: return a % m
    x = powmod(a, b//2, m)**2 % m
    if b % 2 == 0: return x
    return (x * a) % m










Challenge: Hash String

Now let’s solve the problem of encoding. As we mentioned previously, searching by simply comparing characters takes ages - so how can we speed up those comparisons?

Comparisons can be conducted faster if we do them on numbers rather than characters. So, we’ll just represent the characters as numbers and compare them as if they’re numbers.

During this challenge you’ll implement a way to encode (i.e: hashing) the characters into numbers.

Consider the string S = s0s1s2..sm-1, we define the hash value of S in the following way:

hash(S) = (a0 * 10m-1 + a1 * 10m-2 + … am-1 * 100) modulo 104677

where ai is the ASCII value of character si in the given string.

Given two strings S and T

Your task is to

    * write a function that prints to the standard output (stdout) how many substrings from T have the same length with S and also the same hash value
    * a substring is a sequence of consecutive characters from a given string

Note that your function will receive the following arguments:

    * s
          o which is the string "S" described above
    * t
          o which is the string "T" described above

Data constraints

    * the size of the S string will not exceed 200,000 characters
    * the size of the T string will not exceed 6,000,000 characters

Efficiency constraints

    * your function is expected to print the requested result and return in less than 2 seconds

Example
Input   Output

s: "ab"

t: "cab bac abab"
   

3










